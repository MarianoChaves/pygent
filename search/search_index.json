{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem-vindo ao Pygent","text":"<p>Pygent \u00e9 um assistente de codifica\u00e7\u00e3o minimalista e poderoso, projetado para executar tarefas em um ambiente seguro e isolado. Por padr\u00e3o, ele utiliza cont\u00eaineres Docker para garantir que os comandos sejam executados de forma segura, mas tamb\u00e9m pode operar localmente se o Docker n\u00e3o estiver dispon\u00edvel.</p> <p>Esteja voc\u00ea procurando automatizar tarefas de desenvolvimento, gerar c\u00f3digo ou simplesmente experimentar um assistente de IA seguro, o Pygent oferece as ferramentas e a flexibilidade de que voc\u00ea precisa.</p>"},{"location":"#destaques","title":"Destaques","text":"<ul> <li>Execu\u00e7\u00e3o Segura: Comandos executados em cont\u00eaineres Docker ef\u00eameros por padr\u00e3o.</li> <li>Flexibilidade: Integra-se com modelos de linguagem compat\u00edveis com a API da OpenAI.</li> <li>Extensibilidade: Crie suas pr\u00f3prias ferramentas, personalize os prompts do sistema e estenda a CLI com comandos customizados.</li> <li>Persist\u00eancia: Salve e recupere o estado do seu workspace entre as sess\u00f5es.</li> <li>Interface Dupla: Use o Pygent atrav\u00e9s de uma CLI interativa ou de uma interface web simples.</li> </ul>"},{"location":"#por-onde-comecar","title":"Por onde come\u00e7ar?","text":"<ul> <li>Novo no Pygent? Confira o nosso Guia de In\u00edcio R\u00e1pido para instalar e executar seu primeiro agente.</li> <li>Quer usar a CLI? A p\u00e1gina sobre a Interface de Linha de Comando (CLI) tem todos os detalhes.</li> <li>Pronto para customizar? Aprenda a criar Ferramentas e Modelos Customizados.</li> <li>Deseja entender como funciona? A se\u00e7\u00e3o de Arquitetura oferece uma vis\u00e3o geral dos componentes internos.</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section documents the main classes and helpers exposed by Pygent. The content is generated from the package docstrings.</p>"},{"location":"api-reference/#agent","title":"Agent","text":"<p>Interactive assistant handling messages and tool execution.</p> Source code in <code>pygent/agent.py</code> <pre><code>@dataclass\nclass Agent:\n    \"\"\"Interactive assistant handling messages and tool execution.\"\"\"\n    runtime: Runtime = field(default_factory=Runtime)\n    model: Model = field(default_factory=_default_model)\n    model_name: str = DEFAULT_MODEL\n    persona: Persona = field(default_factory=lambda: DEFAULT_PERSONA)\n    system_msg: str = field(default_factory=lambda: build_system_msg(DEFAULT_PERSONA))\n    history: List[Dict[str, Any]] = field(default_factory=list)\n    history_file: Optional[pathlib.Path] = field(default_factory=_default_history_file)\n    disabled_tools: List[str] = field(default_factory=list)\n    log_file: Optional[pathlib.Path] = field(default_factory=_default_log_file)\n    confirm_bash: bool = field(default_factory=_default_confirm_bash)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize defaults after dataclass construction.\"\"\"\n        self._log_fp = None\n        if not self.system_msg:\n            self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n        if self.history_file and isinstance(self.history_file, (str, pathlib.Path)):\n            self.history_file = pathlib.Path(self.history_file)\n            if self.history_file.is_file():\n                try:\n                    with self.history_file.open(\"r\", encoding=\"utf-8\") as fh:\n                        data = json.load(fh)\n                except Exception:\n                    data = []\n                self.history = [\n                    openai_compat.parse_message(m) if isinstance(m, dict) else m\n                    for m in data\n                ]\n        if not self.history:\n            self.append_history({\"role\": \"system\", \"content\": self.system_msg})\n        if self.log_file is None:\n            if hasattr(self.runtime, \"base_dir\"):\n                self.log_file = pathlib.Path(getattr(self.runtime, \"base_dir\")) / \"cli.log\"\n            else:\n                self.log_file = pathlib.Path(\"cli.log\")\n        if isinstance(self.log_file, (str, pathlib.Path)):\n            self.log_file = pathlib.Path(self.log_file)\n            os.environ.setdefault(\"PYGENT_LOG_FILE\", str(self.log_file))\n            self.log_file.parent.mkdir(parents=True, exist_ok=True)\n            try:\n                self._log_fp = self.log_file.open(\"a\", encoding=\"utf-8\")\n            except Exception:\n                self._log_fp = None\n\n    def _message_dict(self, msg: Any) -&gt; Dict[str, Any]:\n        if isinstance(msg, dict):\n            return msg\n        if isinstance(msg, openai_compat.Message):\n            data = {\"role\": msg.role, \"content\": msg.content}\n            if msg.tool_calls:\n                data[\"tool_calls\"] = [asdict(tc) for tc in msg.tool_calls]\n            return data\n        raise TypeError(f\"Unsupported message type: {type(msg)!r}\")\n\n    def _save_history(self) -&gt; None:\n        if self.history_file:\n            self.history_file.parent.mkdir(parents=True, exist_ok=True)\n            with self.history_file.open(\"w\", encoding=\"utf-8\") as fh:\n                json.dump([self._message_dict(m) for m in self.history], fh)\n\n    def append_history(self, msg: Any) -&gt; None:\n        self.history.append(msg)\n        self._save_history()\n        if self._log_fp:\n            try:\n                self._log_fp.write(json.dumps(self._message_dict(msg)) + \"\\n\")\n                self._log_fp.flush()\n            except Exception:\n                pass\n\n    def refresh_system_message(self) -&gt; None:\n        \"\"\"Update the system prompt based on the current tool registry.\"\"\"\n        self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n        if self.history and self.history[0].get(\"role\") == \"system\":\n            self.history[0][\"content\"] = self.system_msg\n\n    def step(self, user_msg: str):\n        \"\"\"Execute one round of interaction with the model.\"\"\"\n\n        self.refresh_system_message()\n        self.append_history({\"role\": \"user\", \"content\": user_msg})\n\n        status_cm = (\n            console.status(\"[bold cyan]Thinking...\", spinner=\"dots\")\n            if hasattr(console, \"status\")\n            else nullcontext()\n        )\n        schemas = [\n            s\n            for s in tools.TOOL_SCHEMAS\n            if s[\"function\"][\"name\"] not in self.disabled_tools\n        ]\n        with status_cm:\n            assistant_raw = self.model.chat(\n                self.history, self.model_name, schemas\n            )\n        assistant_msg = openai_compat.parse_message(assistant_raw)\n        self.append_history(assistant_msg)\n\n        if assistant_msg.tool_calls:\n            for call in assistant_msg.tool_calls:\n                if self.confirm_bash and call.function.name == \"bash\":\n                    args = json.loads(call.function.arguments or \"{}\")\n                    cmd = args.get(\"cmd\", \"\")\n                    prompt = f\"Run command: {cmd}?\"\n                    if questionary:\n                        ok = questionary.confirm(prompt).ask()\n                    else:  # pragma: no cover - fallback for tests\n                        ok = input(f\"{prompt} [y/N]: \").lower().startswith(\"y\")\n                    if not ok:\n                        output = f\"$ {cmd}\\n[aborted]\"\n                        self.append_history({\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id})\n                        console.print(\n                            Panel(\n                                output,\n                                title=f\"{self.persona.name} tool:{call.function.name}\",\n                                box=box.ROUNDED if box else None,\n                            )\n                        )\n                        continue\n                status_cm = (\n                    console.status(\n                        f\"[green]Running {call.function.name}...\", spinner=\"line\"\n                    )\n                    if hasattr(console, \"status\")\n                    else nullcontext()\n                )\n                with status_cm:\n                    output = tools.execute_tool(call, self.runtime)\n                self.append_history(\n                    {\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id}\n                )\n                if call.function.name not in {\"continue\", \"stop\"}:\n                    console.print(\n                        Panel(\n                            output,\n                            title=f\"{self.persona.name} tool:{call.function.name}\",\n                            box=box.ROUNDED if box else None,\n                        )\n                    )\n        else:\n            markdown_response = Markdown(assistant_msg.content)\n            console.print(\n                Panel(\n                    markdown_response,\n                    title=f\"{self.persona.name} replied\",\n                    title_align=\"left\",\n                    border_style=\"cyan\",\n                    box=box.ROUNDED if box else None,\n                )\n            )\n        return assistant_msg\n\n    def run_until_stop(\n        self,\n        user_msg: str,\n        max_steps: int = 20,\n        step_timeout: Optional[float] = None,\n        max_time: Optional[float] = None,\n    ) -&gt; Optional[openai_compat.Message]:\n        \"\"\"Run steps until ``stop`` is called or limits are reached.\"\"\"\n\n        if step_timeout is None:\n            env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n            step_timeout = float(env) if env else None\n        if max_time is None:\n            env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n            max_time = float(env) if env else None\n\n        msg = user_msg\n        start = time.monotonic()\n        self._timed_out = False\n        last_msg = None\n        for _ in range(max_steps):\n            if max_time is not None and time.monotonic() - start &gt; max_time:\n                self.append_history(\n                    {\"role\": \"system\", \"content\": f\"[timeout after {max_time}s]\"}\n                )\n                self._timed_out = True\n                break\n            step_start = time.monotonic()\n            assistant_msg = self.step(msg)\n            last_msg = assistant_msg\n            if (\n                step_timeout is not None\n                and time.monotonic() - step_start &gt; step_timeout\n            ):\n                self.append_history(\n                    {\"role\": \"system\", \"content\": f\"[timeout after {step_timeout}s]\"}\n                )\n                self._timed_out = True\n                break\n            calls = assistant_msg.tool_calls or []\n            if any(c.function.name in (\"stop\", \"continue\") for c in calls):\n                break\n            msg = \"continue\"\n\n        return last_msg\n\n    def close(self) -&gt; None:\n        \"\"\"Close any open resources.\"\"\"\n        if self._log_fp:\n            try:\n                self._log_fp.close()\n            finally:\n                self._log_fp = None\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize defaults after dataclass construction.</p> Source code in <code>pygent/agent.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize defaults after dataclass construction.\"\"\"\n    self._log_fp = None\n    if not self.system_msg:\n        self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n    if self.history_file and isinstance(self.history_file, (str, pathlib.Path)):\n        self.history_file = pathlib.Path(self.history_file)\n        if self.history_file.is_file():\n            try:\n                with self.history_file.open(\"r\", encoding=\"utf-8\") as fh:\n                    data = json.load(fh)\n            except Exception:\n                data = []\n            self.history = [\n                openai_compat.parse_message(m) if isinstance(m, dict) else m\n                for m in data\n            ]\n    if not self.history:\n        self.append_history({\"role\": \"system\", \"content\": self.system_msg})\n    if self.log_file is None:\n        if hasattr(self.runtime, \"base_dir\"):\n            self.log_file = pathlib.Path(getattr(self.runtime, \"base_dir\")) / \"cli.log\"\n        else:\n            self.log_file = pathlib.Path(\"cli.log\")\n    if isinstance(self.log_file, (str, pathlib.Path)):\n        self.log_file = pathlib.Path(self.log_file)\n        os.environ.setdefault(\"PYGENT_LOG_FILE\", str(self.log_file))\n        self.log_file.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            self._log_fp = self.log_file.open(\"a\", encoding=\"utf-8\")\n        except Exception:\n            self._log_fp = None\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.close","title":"<code>close()</code>","text":"<p>Close any open resources.</p> Source code in <code>pygent/agent.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close any open resources.\"\"\"\n    if self._log_fp:\n        try:\n            self._log_fp.close()\n        finally:\n            self._log_fp = None\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.refresh_system_message","title":"<code>refresh_system_message()</code>","text":"<p>Update the system prompt based on the current tool registry.</p> Source code in <code>pygent/agent.py</code> <pre><code>def refresh_system_message(self) -&gt; None:\n    \"\"\"Update the system prompt based on the current tool registry.\"\"\"\n    self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n    if self.history and self.history[0].get(\"role\") == \"system\":\n        self.history[0][\"content\"] = self.system_msg\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.run_until_stop","title":"<code>run_until_stop(user_msg, max_steps=20, step_timeout=None, max_time=None)</code>","text":"<p>Run steps until <code>stop</code> is called or limits are reached.</p> Source code in <code>pygent/agent.py</code> <pre><code>def run_until_stop(\n    self,\n    user_msg: str,\n    max_steps: int = 20,\n    step_timeout: Optional[float] = None,\n    max_time: Optional[float] = None,\n) -&gt; Optional[openai_compat.Message]:\n    \"\"\"Run steps until ``stop`` is called or limits are reached.\"\"\"\n\n    if step_timeout is None:\n        env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n        step_timeout = float(env) if env else None\n    if max_time is None:\n        env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n        max_time = float(env) if env else None\n\n    msg = user_msg\n    start = time.monotonic()\n    self._timed_out = False\n    last_msg = None\n    for _ in range(max_steps):\n        if max_time is not None and time.monotonic() - start &gt; max_time:\n            self.append_history(\n                {\"role\": \"system\", \"content\": f\"[timeout after {max_time}s]\"}\n            )\n            self._timed_out = True\n            break\n        step_start = time.monotonic()\n        assistant_msg = self.step(msg)\n        last_msg = assistant_msg\n        if (\n            step_timeout is not None\n            and time.monotonic() - step_start &gt; step_timeout\n        ):\n            self.append_history(\n                {\"role\": \"system\", \"content\": f\"[timeout after {step_timeout}s]\"}\n            )\n            self._timed_out = True\n            break\n        calls = assistant_msg.tool_calls or []\n        if any(c.function.name in (\"stop\", \"continue\") for c in calls):\n            break\n        msg = \"continue\"\n\n    return last_msg\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.step","title":"<code>step(user_msg)</code>","text":"<p>Execute one round of interaction with the model.</p> Source code in <code>pygent/agent.py</code> <pre><code>def step(self, user_msg: str):\n    \"\"\"Execute one round of interaction with the model.\"\"\"\n\n    self.refresh_system_message()\n    self.append_history({\"role\": \"user\", \"content\": user_msg})\n\n    status_cm = (\n        console.status(\"[bold cyan]Thinking...\", spinner=\"dots\")\n        if hasattr(console, \"status\")\n        else nullcontext()\n    )\n    schemas = [\n        s\n        for s in tools.TOOL_SCHEMAS\n        if s[\"function\"][\"name\"] not in self.disabled_tools\n    ]\n    with status_cm:\n        assistant_raw = self.model.chat(\n            self.history, self.model_name, schemas\n        )\n    assistant_msg = openai_compat.parse_message(assistant_raw)\n    self.append_history(assistant_msg)\n\n    if assistant_msg.tool_calls:\n        for call in assistant_msg.tool_calls:\n            if self.confirm_bash and call.function.name == \"bash\":\n                args = json.loads(call.function.arguments or \"{}\")\n                cmd = args.get(\"cmd\", \"\")\n                prompt = f\"Run command: {cmd}?\"\n                if questionary:\n                    ok = questionary.confirm(prompt).ask()\n                else:  # pragma: no cover - fallback for tests\n                    ok = input(f\"{prompt} [y/N]: \").lower().startswith(\"y\")\n                if not ok:\n                    output = f\"$ {cmd}\\n[aborted]\"\n                    self.append_history({\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id})\n                    console.print(\n                        Panel(\n                            output,\n                            title=f\"{self.persona.name} tool:{call.function.name}\",\n                            box=box.ROUNDED if box else None,\n                        )\n                    )\n                    continue\n            status_cm = (\n                console.status(\n                    f\"[green]Running {call.function.name}...\", spinner=\"line\"\n                )\n                if hasattr(console, \"status\")\n                else nullcontext()\n            )\n            with status_cm:\n                output = tools.execute_tool(call, self.runtime)\n            self.append_history(\n                {\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id}\n            )\n            if call.function.name not in {\"continue\", \"stop\"}:\n                console.print(\n                    Panel(\n                        output,\n                        title=f\"{self.persona.name} tool:{call.function.name}\",\n                        box=box.ROUNDED if box else None,\n                    )\n                )\n    else:\n        markdown_response = Markdown(assistant_msg.content)\n        console.print(\n            Panel(\n                markdown_response,\n                title=f\"{self.persona.name} replied\",\n                title_align=\"left\",\n                border_style=\"cyan\",\n                box=box.ROUNDED if box else None,\n            )\n        )\n    return assistant_msg\n</code></pre>"},{"location":"api-reference/#runtime","title":"Runtime","text":"<p>Executes commands in a Docker container or locally if Docker is unavailable.</p> <p>If <code>workspace</code> or the environment variable <code>PYGENT_WORKSPACE</code> is set, the given directory is used as the base workspace and kept across sessions.</p> Source code in <code>pygent/runtime.py</code> <pre><code>class Runtime:\n    \"\"\"Executes commands in a Docker container or locally if Docker is unavailable.\n\n    If ``workspace`` or the environment variable ``PYGENT_WORKSPACE`` is set,\n    the given directory is used as the base workspace and kept across sessions.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Optional[str] = None,\n        use_docker: Optional[bool] = None,\n        initial_files: Optional[list[str]] = None,\n        workspace: Optional[Union[str, Path]] = None,\n        banned_commands: Optional[list[str]] = None,\n        banned_apps: Optional[list[str]] = None,\n    ) -&gt; None:\n        \"\"\"Create a new execution runtime.\n\n        ``banned_commands`` and ``banned_apps`` can be used to restrict what\n        can be run. Environment variables ``PYGENT_BANNED_COMMANDS`` and\n        ``PYGENT_BANNED_APPS`` extend these lists using ``os.pathsep`` as the\n        delimiter.\n        \"\"\"\n        env_ws = os.getenv(\"PYGENT_WORKSPACE\")\n        if workspace is None and env_ws:\n            workspace = env_ws\n        if workspace is None:\n            self.base_dir = Path.cwd() / f\"agent_{uuid.uuid4().hex[:8]}\"\n            self._persistent = False\n        else:\n            self.base_dir = Path(workspace).expanduser()\n            self._persistent = True\n        self.base_dir.mkdir(parents=True, exist_ok=True)\n        if initial_files is None:\n            env_files = os.getenv(\"PYGENT_INIT_FILES\")\n            if env_files:\n                initial_files = [f.strip() for f in env_files.split(os.pathsep) if f.strip()]\n        self._initial_files = initial_files or []\n        self.image = image or os.getenv(\"PYGENT_IMAGE\", \"python:3.12-slim\")\n        env_opt = os.getenv(\"PYGENT_USE_DOCKER\")\n        if use_docker is None:\n            use_docker = (env_opt != \"0\") if env_opt is not None else True\n        self._use_docker = bool(docker) and use_docker\n        if self._use_docker:\n            try:\n                self.client = docker.from_env()\n                self.container = self.client.containers.run(\n                    self.image,\n                    name=f\"pygent-{uuid.uuid4().hex[:8]}\",\n                    command=\"sleep infinity\",\n                    volumes={str(self.base_dir): {\"bind\": \"/workspace\", \"mode\": \"rw\"}},\n                    working_dir=\"/workspace\",\n                    detach=True,\n                    tty=True,\n                    network_disabled=True,\n                    mem_limit=\"512m\",\n                    pids_limit=256,\n                )\n            except Exception:\n                self._use_docker = False\n        if not self._use_docker:\n            self.client = None\n            self.container = None\n\n        # populate workspace with initial files\n        for fp in self._initial_files:\n            src = Path(fp).expanduser()\n            dest = self.base_dir / src.name\n            if src.is_dir():\n                shutil.copytree(src, dest, dirs_exist_ok=True)\n            elif src.exists():\n                dest.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(src, dest)\n\n        env_banned_cmds = os.getenv(\"PYGENT_BANNED_COMMANDS\")\n        env_banned_apps = os.getenv(\"PYGENT_BANNED_APPS\")\n        self.banned_commands = set(banned_commands or [])\n        if env_banned_cmds:\n            self.banned_commands.update(c.strip() for c in env_banned_cmds.split(os.pathsep) if c.strip())\n        self.banned_apps = set(banned_apps or [])\n        if env_banned_apps:\n            self.banned_apps.update(a.strip() for a in env_banned_apps.split(os.pathsep) if a.strip())\n\n    @property\n    def use_docker(self) -&gt; bool:\n        \"\"\"Return ``True`` if commands run inside a Docker container.\"\"\"\n        return self._use_docker\n\n    # ---------------- public API ----------------\n    def bash(self, cmd: str, timeout: int = 30) -&gt; str:\n        \"\"\"Run a command in the container or locally and return the output.\n\n        The executed command is always included in the returned string so the\n        caller can display what was run.\n        \"\"\"\n        tokens = cmd.split()\n        if tokens:\n            from pathlib import Path\n\n            if Path(tokens[0]).name in self.banned_commands:\n                return f\"$ {cmd}\\n[error] command '{tokens[0]}' disabled\"\n            for t in tokens:\n                if Path(t).name in self.banned_apps:\n                    return f\"$ {cmd}\\n[error] application '{Path(t).name}' disabled\"\n        if self._use_docker and self.container is not None:\n            try:\n                res = self.container.exec_run(\n                    cmd,\n                    workdir=\"/workspace\",\n                    demux=True,\n                    tty=False,\n                    stdin=False,\n                    timeout=timeout,\n                )\n                stdout, stderr = (\n                    res.output if isinstance(res.output, tuple) else (res.output, b\"\")\n                )\n                output = (stdout or b\"\").decode() + (stderr or b\"\").decode()\n                return f\"$ {cmd}\\n{output}\"\n            except Exception as exc:\n                return f\"$ {cmd}\\n[error] {exc}\"\n        try:\n            proc = subprocess.run(\n                cmd,\n                shell=True,\n                cwd=self.base_dir,\n                capture_output=True,\n                text=True,\n                stdin=subprocess.DEVNULL,\n                timeout=timeout,\n            )\n            return f\"$ {cmd}\\n{proc.stdout + proc.stderr}\"\n        except subprocess.TimeoutExpired:\n            return f\"$ {cmd}\\n[timeout after {timeout}s]\"\n        except Exception as exc:\n            return f\"$ {cmd}\\n[error] {exc}\"\n\n    def write_file(self, path: Union[str, Path], content: str) -&gt; str:\n        p = self.base_dir / path\n        p.parent.mkdir(parents=True, exist_ok=True)\n        p.write_text(content, encoding=\"utf-8\")\n        return f\"Wrote {p.relative_to(self.base_dir)}\"\n\n    def read_file(self, path: Union[str, Path], binary: bool = False) -&gt; str:\n        \"\"\"Return the contents of a file relative to the workspace.\"\"\"\n\n        p = self.base_dir / path\n        if not p.exists():\n            return f\"file {p.relative_to(self.base_dir)} not found\"\n        data = p.read_bytes()\n        if binary:\n            import base64\n\n            return base64.b64encode(data).decode()\n        try:\n            return data.decode()\n        except UnicodeDecodeError:\n            import base64\n\n            return base64.b64encode(data).decode()\n\n    def upload_file(self, src: Union[str, Path], dest: Optional[Union[str, Path]] = None) -&gt; str:\n        \"\"\"Copy a local file or directory into the workspace.\"\"\"\n\n        src_path = Path(src).expanduser()\n        if not src_path.exists():\n            return f\"file {src} not found\"\n        target = self.base_dir / (Path(dest) if dest else src_path.name)\n        if src_path.is_dir():\n            shutil.copytree(src_path, target, dirs_exist_ok=True)\n        else:\n            target.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src_path, target)\n        return f\"Uploaded {target.relative_to(self.base_dir)}\"\n\n    def export_file(self, path: Union[str, Path], dest: Union[str, Path]) -&gt; str:\n        \"\"\"Copy a file or directory from the workspace to a local path.\"\"\"\n\n        src = self.base_dir / path\n        if not src.exists():\n            return f\"file {path} not found\"\n        dest_path = Path(dest).expanduser()\n        if src.is_dir():\n            shutil.copytree(src, dest_path, dirs_exist_ok=True)\n        else:\n            dest_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest_path)\n        return f\"Exported {src.relative_to(self.base_dir)}\"\n\n    def cleanup(self) -&gt; None:\n        if self._use_docker and self.container is not None:\n            try:\n                self.container.kill()\n            finally:\n                self.container.remove(force=True)\n        if not self._persistent:\n            shutil.rmtree(self.base_dir, ignore_errors=True)\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.use_docker","title":"<code>use_docker</code>  <code>property</code>","text":"<p>Return <code>True</code> if commands run inside a Docker container.</p>"},{"location":"api-reference/#pygent.runtime.Runtime.__init__","title":"<code>__init__(image=None, use_docker=None, initial_files=None, workspace=None, banned_commands=None, banned_apps=None)</code>","text":"<p>Create a new execution runtime.</p> <p><code>banned_commands</code> and <code>banned_apps</code> can be used to restrict what can be run. Environment variables <code>PYGENT_BANNED_COMMANDS</code> and <code>PYGENT_BANNED_APPS</code> extend these lists using <code>os.pathsep</code> as the delimiter.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def __init__(\n    self,\n    image: Optional[str] = None,\n    use_docker: Optional[bool] = None,\n    initial_files: Optional[list[str]] = None,\n    workspace: Optional[Union[str, Path]] = None,\n    banned_commands: Optional[list[str]] = None,\n    banned_apps: Optional[list[str]] = None,\n) -&gt; None:\n    \"\"\"Create a new execution runtime.\n\n    ``banned_commands`` and ``banned_apps`` can be used to restrict what\n    can be run. Environment variables ``PYGENT_BANNED_COMMANDS`` and\n    ``PYGENT_BANNED_APPS`` extend these lists using ``os.pathsep`` as the\n    delimiter.\n    \"\"\"\n    env_ws = os.getenv(\"PYGENT_WORKSPACE\")\n    if workspace is None and env_ws:\n        workspace = env_ws\n    if workspace is None:\n        self.base_dir = Path.cwd() / f\"agent_{uuid.uuid4().hex[:8]}\"\n        self._persistent = False\n    else:\n        self.base_dir = Path(workspace).expanduser()\n        self._persistent = True\n    self.base_dir.mkdir(parents=True, exist_ok=True)\n    if initial_files is None:\n        env_files = os.getenv(\"PYGENT_INIT_FILES\")\n        if env_files:\n            initial_files = [f.strip() for f in env_files.split(os.pathsep) if f.strip()]\n    self._initial_files = initial_files or []\n    self.image = image or os.getenv(\"PYGENT_IMAGE\", \"python:3.12-slim\")\n    env_opt = os.getenv(\"PYGENT_USE_DOCKER\")\n    if use_docker is None:\n        use_docker = (env_opt != \"0\") if env_opt is not None else True\n    self._use_docker = bool(docker) and use_docker\n    if self._use_docker:\n        try:\n            self.client = docker.from_env()\n            self.container = self.client.containers.run(\n                self.image,\n                name=f\"pygent-{uuid.uuid4().hex[:8]}\",\n                command=\"sleep infinity\",\n                volumes={str(self.base_dir): {\"bind\": \"/workspace\", \"mode\": \"rw\"}},\n                working_dir=\"/workspace\",\n                detach=True,\n                tty=True,\n                network_disabled=True,\n                mem_limit=\"512m\",\n                pids_limit=256,\n            )\n        except Exception:\n            self._use_docker = False\n    if not self._use_docker:\n        self.client = None\n        self.container = None\n\n    # populate workspace with initial files\n    for fp in self._initial_files:\n        src = Path(fp).expanduser()\n        dest = self.base_dir / src.name\n        if src.is_dir():\n            shutil.copytree(src, dest, dirs_exist_ok=True)\n        elif src.exists():\n            dest.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest)\n\n    env_banned_cmds = os.getenv(\"PYGENT_BANNED_COMMANDS\")\n    env_banned_apps = os.getenv(\"PYGENT_BANNED_APPS\")\n    self.banned_commands = set(banned_commands or [])\n    if env_banned_cmds:\n        self.banned_commands.update(c.strip() for c in env_banned_cmds.split(os.pathsep) if c.strip())\n    self.banned_apps = set(banned_apps or [])\n    if env_banned_apps:\n        self.banned_apps.update(a.strip() for a in env_banned_apps.split(os.pathsep) if a.strip())\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.bash","title":"<code>bash(cmd, timeout=30)</code>","text":"<p>Run a command in the container or locally and return the output.</p> <p>The executed command is always included in the returned string so the caller can display what was run.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def bash(self, cmd: str, timeout: int = 30) -&gt; str:\n    \"\"\"Run a command in the container or locally and return the output.\n\n    The executed command is always included in the returned string so the\n    caller can display what was run.\n    \"\"\"\n    tokens = cmd.split()\n    if tokens:\n        from pathlib import Path\n\n        if Path(tokens[0]).name in self.banned_commands:\n            return f\"$ {cmd}\\n[error] command '{tokens[0]}' disabled\"\n        for t in tokens:\n            if Path(t).name in self.banned_apps:\n                return f\"$ {cmd}\\n[error] application '{Path(t).name}' disabled\"\n    if self._use_docker and self.container is not None:\n        try:\n            res = self.container.exec_run(\n                cmd,\n                workdir=\"/workspace\",\n                demux=True,\n                tty=False,\n                stdin=False,\n                timeout=timeout,\n            )\n            stdout, stderr = (\n                res.output if isinstance(res.output, tuple) else (res.output, b\"\")\n            )\n            output = (stdout or b\"\").decode() + (stderr or b\"\").decode()\n            return f\"$ {cmd}\\n{output}\"\n        except Exception as exc:\n            return f\"$ {cmd}\\n[error] {exc}\"\n    try:\n        proc = subprocess.run(\n            cmd,\n            shell=True,\n            cwd=self.base_dir,\n            capture_output=True,\n            text=True,\n            stdin=subprocess.DEVNULL,\n            timeout=timeout,\n        )\n        return f\"$ {cmd}\\n{proc.stdout + proc.stderr}\"\n    except subprocess.TimeoutExpired:\n        return f\"$ {cmd}\\n[timeout after {timeout}s]\"\n    except Exception as exc:\n        return f\"$ {cmd}\\n[error] {exc}\"\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.export_file","title":"<code>export_file(path, dest)</code>","text":"<p>Copy a file or directory from the workspace to a local path.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def export_file(self, path: Union[str, Path], dest: Union[str, Path]) -&gt; str:\n    \"\"\"Copy a file or directory from the workspace to a local path.\"\"\"\n\n    src = self.base_dir / path\n    if not src.exists():\n        return f\"file {path} not found\"\n    dest_path = Path(dest).expanduser()\n    if src.is_dir():\n        shutil.copytree(src, dest_path, dirs_exist_ok=True)\n    else:\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src, dest_path)\n    return f\"Exported {src.relative_to(self.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.read_file","title":"<code>read_file(path, binary=False)</code>","text":"<p>Return the contents of a file relative to the workspace.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def read_file(self, path: Union[str, Path], binary: bool = False) -&gt; str:\n    \"\"\"Return the contents of a file relative to the workspace.\"\"\"\n\n    p = self.base_dir / path\n    if not p.exists():\n        return f\"file {p.relative_to(self.base_dir)} not found\"\n    data = p.read_bytes()\n    if binary:\n        import base64\n\n        return base64.b64encode(data).decode()\n    try:\n        return data.decode()\n    except UnicodeDecodeError:\n        import base64\n\n        return base64.b64encode(data).decode()\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.upload_file","title":"<code>upload_file(src, dest=None)</code>","text":"<p>Copy a local file or directory into the workspace.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def upload_file(self, src: Union[str, Path], dest: Optional[Union[str, Path]] = None) -&gt; str:\n    \"\"\"Copy a local file or directory into the workspace.\"\"\"\n\n    src_path = Path(src).expanduser()\n    if not src_path.exists():\n        return f\"file {src} not found\"\n    target = self.base_dir / (Path(dest) if dest else src_path.name)\n    if src_path.is_dir():\n        shutil.copytree(src_path, target, dirs_exist_ok=True)\n    else:\n        target.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src_path, target)\n    return f\"Uploaded {target.relative_to(self.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#taskmanager","title":"TaskManager","text":"<p>Launch agents asynchronously and track their progress.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>class TaskManager:\n    \"\"\"Launch agents asynchronously and track their progress.\"\"\"\n\n    def __init__(\n        self,\n        agent_factory: Optional[Callable[..., \"Agent\"]] = None,\n        max_tasks: Optional[int] = None,\n        personas: Optional[list[Persona]] = None,\n    ) -&gt; None:\n        from .agent import Agent  # local import to avoid circular dependency\n\n        env_max = os.getenv(\"PYGENT_MAX_TASKS\")\n        self.max_tasks = max_tasks if max_tasks is not None else int(env_max or \"3\")\n        if agent_factory is None:\n            self.agent_factory = lambda p=None: Agent(persona=p)\n        else:\n            self.agent_factory = agent_factory\n        env_personas_json = os.getenv(\"PYGENT_TASK_PERSONAS_JSON\")\n        if personas is None and env_personas_json:\n            try:\n                data = json.loads(env_personas_json)\n                if isinstance(data, list):\n                    personas = [\n                        Persona(p.get(\"name\", \"\"), p.get(\"description\", \"\"))\n                        for p in data\n                        if isinstance(p, dict)\n                    ]\n            except Exception:\n                personas = None\n        env_personas = os.getenv(\"PYGENT_TASK_PERSONAS\")\n        if personas is None and env_personas:\n            personas = [\n                Persona(p.strip(), \"\")\n                for p in env_personas.split(os.pathsep)\n                if p.strip()\n            ]\n        if personas is None:\n            personas = [\n                Persona(\n                    os.getenv(\"PYGENT_PERSONA_NAME\", \"Pygent\"),\n                    os.getenv(\"PYGENT_PERSONA\", \"a sandboxed coding assistant.\"),\n                )\n            ]\n        self.personas = personas\n        self._persona_idx = 0\n        self.tasks: Dict[str, Task] = {}\n        self._lock = threading.Lock()\n\n    def start_task(\n        self,\n        prompt: str,\n        parent_rt: Runtime,\n        files: Optional[list[str]] = None,\n        parent_depth: int = 0,\n        step_timeout: Optional[float] = None,\n        task_timeout: Optional[float] = None,\n        persona: Union[Persona, str, None] = None,\n    ) -&gt; str:\n        \"\"\"Create a new agent and run ``prompt`` asynchronously.\n\n        ``persona`` overrides the default rotation used for delegated tasks.\n        \"\"\"\n\n        if parent_depth &gt;= 1:\n            raise RuntimeError(\"nested delegation is not allowed\")\n\n        with self._lock:\n            active = sum(t.status == \"running\" for t in self.tasks.values())\n            if active &gt;= self.max_tasks:\n                raise RuntimeError(f\"max {self.max_tasks} tasks reached\")\n\n        if step_timeout is None:\n            env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n            step_timeout = float(env) if env else 60 * 5  # default 5 minutes\n        if task_timeout is None:\n            env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n            task_timeout = float(env) if env else 60 * 20  # default 20 minutes\n\n        if persona is None:\n            persona = self.personas[self._persona_idx % len(self.personas)]\n            self._persona_idx += 1\n        elif isinstance(persona, str):\n            match = next((p for p in self.personas if p.name == persona), None)\n            persona = match or Persona(persona, \"\")\n        try:\n            agent = self.agent_factory(persona)\n        except TypeError:\n            agent = self.agent_factory()\n\n        from .runtime import Runtime\n        if getattr(agent, \"runtime\", None) is not None:\n            try:\n                agent.runtime.cleanup()\n            except Exception:\n                pass\n        task_dir = parent_rt.base_dir / f\"task_{uuid.uuid4().hex[:8]}\"\n        agent.runtime = Runtime(use_docker=parent_rt.use_docker, workspace=task_dir)\n        setattr(agent, \"persona\", persona)\n        if not getattr(agent, \"system_msg\", None):\n            from .agent import build_system_msg  # lazy import\n\n            agent.system_msg = build_system_msg(persona)\n        setattr(agent.runtime, \"task_depth\", parent_depth + 1)\n        if files:\n            for fp in files:\n                src = parent_rt.base_dir / fp\n                dest = agent.runtime.base_dir / fp\n                if src.is_dir():\n                    shutil.copytree(src, dest, dirs_exist_ok=True)\n                elif src.exists():\n                    dest.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy(src, dest)\n        task_id = uuid.uuid4().hex[:8]\n        task = Task(id=task_id, agent=agent, thread=None)  # type: ignore[arg-type]\n\n        def run() -&gt; None:\n            try:\n                agent.run_until_stop(\n                    prompt,\n                    step_timeout=step_timeout,\n                    max_time=task_timeout,\n                )\n                if getattr(agent, \"_timed_out\", False):\n                    task.status = f\"timeout after {task_timeout}s\"\n                else:\n                    task.status = \"finished\"\n            except Exception as exc:  # pragma: no cover - error propagation\n                task.status = f\"error: {exc}\"\n\n        t = threading.Thread(target=run, daemon=True)\n        task.thread = t\n        with self._lock:\n            self.tasks[task_id] = task\n        t.start()\n        return task_id\n\n    def status(self, task_id: str) -&gt; str:\n        with self._lock:\n            task = self.tasks.get(task_id)\n        if not task:\n            return f\"Task {task_id} not found\"\n        return task.status\n\n    def collect_file(\n        self, rt: Runtime, task_id: str, path: str, dest: Optional[str] = None\n    ) -&gt; str:\n        \"\"\"Copy a file or directory from a task workspace into ``rt``.\"\"\"\n\n        with self._lock:\n            task = self.tasks.get(task_id)\n        if not task:\n            return f\"Task {task_id} not found\"\n        src = task.agent.runtime.base_dir / path\n        if not src.exists():\n            return f\"file {path} not found\"\n        dest_path = rt.base_dir / (dest or path)\n        if src.is_dir():\n            shutil.copytree(src, dest_path, dirs_exist_ok=True)\n        else:\n            dest_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest_path)\n        return f\"Retrieved {dest_path.relative_to(rt.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.task_manager.TaskManager.collect_file","title":"<code>collect_file(rt, task_id, path, dest=None)</code>","text":"<p>Copy a file or directory from a task workspace into <code>rt</code>.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>def collect_file(\n    self, rt: Runtime, task_id: str, path: str, dest: Optional[str] = None\n) -&gt; str:\n    \"\"\"Copy a file or directory from a task workspace into ``rt``.\"\"\"\n\n    with self._lock:\n        task = self.tasks.get(task_id)\n    if not task:\n        return f\"Task {task_id} not found\"\n    src = task.agent.runtime.base_dir / path\n    if not src.exists():\n        return f\"file {path} not found\"\n    dest_path = rt.base_dir / (dest or path)\n    if src.is_dir():\n        shutil.copytree(src, dest_path, dirs_exist_ok=True)\n    else:\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src, dest_path)\n    return f\"Retrieved {dest_path.relative_to(rt.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.task_manager.TaskManager.start_task","title":"<code>start_task(prompt, parent_rt, files=None, parent_depth=0, step_timeout=None, task_timeout=None, persona=None)</code>","text":"<p>Create a new agent and run <code>prompt</code> asynchronously.</p> <p><code>persona</code> overrides the default rotation used for delegated tasks.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>def start_task(\n    self,\n    prompt: str,\n    parent_rt: Runtime,\n    files: Optional[list[str]] = None,\n    parent_depth: int = 0,\n    step_timeout: Optional[float] = None,\n    task_timeout: Optional[float] = None,\n    persona: Union[Persona, str, None] = None,\n) -&gt; str:\n    \"\"\"Create a new agent and run ``prompt`` asynchronously.\n\n    ``persona`` overrides the default rotation used for delegated tasks.\n    \"\"\"\n\n    if parent_depth &gt;= 1:\n        raise RuntimeError(\"nested delegation is not allowed\")\n\n    with self._lock:\n        active = sum(t.status == \"running\" for t in self.tasks.values())\n        if active &gt;= self.max_tasks:\n            raise RuntimeError(f\"max {self.max_tasks} tasks reached\")\n\n    if step_timeout is None:\n        env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n        step_timeout = float(env) if env else 60 * 5  # default 5 minutes\n    if task_timeout is None:\n        env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n        task_timeout = float(env) if env else 60 * 20  # default 20 minutes\n\n    if persona is None:\n        persona = self.personas[self._persona_idx % len(self.personas)]\n        self._persona_idx += 1\n    elif isinstance(persona, str):\n        match = next((p for p in self.personas if p.name == persona), None)\n        persona = match or Persona(persona, \"\")\n    try:\n        agent = self.agent_factory(persona)\n    except TypeError:\n        agent = self.agent_factory()\n\n    from .runtime import Runtime\n    if getattr(agent, \"runtime\", None) is not None:\n        try:\n            agent.runtime.cleanup()\n        except Exception:\n            pass\n    task_dir = parent_rt.base_dir / f\"task_{uuid.uuid4().hex[:8]}\"\n    agent.runtime = Runtime(use_docker=parent_rt.use_docker, workspace=task_dir)\n    setattr(agent, \"persona\", persona)\n    if not getattr(agent, \"system_msg\", None):\n        from .agent import build_system_msg  # lazy import\n\n        agent.system_msg = build_system_msg(persona)\n    setattr(agent.runtime, \"task_depth\", parent_depth + 1)\n    if files:\n        for fp in files:\n            src = parent_rt.base_dir / fp\n            dest = agent.runtime.base_dir / fp\n            if src.is_dir():\n                shutil.copytree(src, dest, dirs_exist_ok=True)\n            elif src.exists():\n                dest.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(src, dest)\n    task_id = uuid.uuid4().hex[:8]\n    task = Task(id=task_id, agent=agent, thread=None)  # type: ignore[arg-type]\n\n    def run() -&gt; None:\n        try:\n            agent.run_until_stop(\n                prompt,\n                step_timeout=step_timeout,\n                max_time=task_timeout,\n            )\n            if getattr(agent, \"_timed_out\", False):\n                task.status = f\"timeout after {task_timeout}s\"\n            else:\n                task.status = \"finished\"\n        except Exception as exc:  # pragma: no cover - error propagation\n            task.status = f\"error: {exc}\"\n\n    t = threading.Thread(target=run, daemon=True)\n    task.thread = t\n    with self._lock:\n        self.tasks[task_id] = task\n    t.start()\n    return task_id\n</code></pre>"},{"location":"api-reference/#tools","title":"Tools","text":"<p>Tool registry and helper utilities.</p>"},{"location":"api-reference/#pygent.tools.clear_tools","title":"<code>clear_tools()</code>","text":"<p>Remove all registered tools globally.</p> Source code in <code>pygent/tools.py</code> <pre><code>def clear_tools() -&gt; None:\n    \"\"\"Remove all registered tools globally.\"\"\"\n    TOOLS.clear()\n    TOOL_SCHEMAS.clear()\n</code></pre>"},{"location":"api-reference/#pygent.tools.execute_tool","title":"<code>execute_tool(call, rt)</code>","text":"<p>Dispatch a tool call.</p> Source code in <code>pygent/tools.py</code> <pre><code>def execute_tool(call: Any, rt: Runtime) -&gt; str:  # pragma: no cover\n    \"\"\"Dispatch a tool call.\"\"\"\n    name = call.function.name\n    args: Dict[str, Any] = json.loads(call.function.arguments)\n    func = TOOLS.get(name)\n    if func is None:\n        return f\"\u26a0\ufe0f unknown tool {name}\"\n    return func(rt, **args)\n</code></pre>"},{"location":"api-reference/#pygent.tools.register_tool","title":"<code>register_tool(name, description, parameters, func)</code>","text":"<p>Register a new callable tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def register_tool(\n    name: str, description: str, parameters: Dict[str, Any], func: Callable[..., str]\n) -&gt; None:\n    \"\"\"Register a new callable tool.\"\"\"\n    if name in TOOLS:\n        raise ValueError(f\"tool {name} already registered\")\n    TOOLS[name] = func\n    TOOL_SCHEMAS.append(\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": name,\n                \"description\": description,\n                \"parameters\": parameters,\n            },\n        }\n    )\n</code></pre>"},{"location":"api-reference/#pygent.tools.remove_tool","title":"<code>remove_tool(name)</code>","text":"<p>Unregister a specific tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def remove_tool(name: str) -&gt; None:\n    \"\"\"Unregister a specific tool.\"\"\"\n    if name not in TOOLS:\n        raise ValueError(f\"tool {name} not registered\")\n    del TOOLS[name]\n    for i, schema in enumerate(TOOL_SCHEMAS):\n        func = schema.get(\"function\", {})\n        if func.get(\"name\") == name:\n            TOOL_SCHEMAS.pop(i)\n            break\n</code></pre>"},{"location":"api-reference/#pygent.tools.reset_tools","title":"<code>reset_tools()</code>","text":"<p>Restore the default built-in tools.</p> Source code in <code>pygent/tools.py</code> <pre><code>def reset_tools() -&gt; None:\n    \"\"\"Restore the default built-in tools.\"\"\"\n    clear_tools()\n    TOOLS.update(BUILTIN_TOOLS)\n    TOOL_SCHEMAS.extend(deepcopy(BUILTIN_TOOL_SCHEMAS))\n</code></pre>"},{"location":"api-reference/#pygent.tools.tool","title":"<code>tool(name, description, parameters)</code>","text":"<p>Decorator for registering a tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def tool(name: str, description: str, parameters: Dict[str, Any]):\n    \"\"\"Decorator for registering a tool.\"\"\"\n\n    def decorator(func: Callable[..., str]) -&gt; Callable[..., str]:\n        register_tool(name, description, parameters, func)\n        return func\n\n    return decorator\n</code></pre>"},{"location":"architecture/","title":"Arquitetura","text":"<p>Entender a arquitetura do Pygent ajuda a customizar e estender o projeto de forma eficaz. O sistema \u00e9 composto por alguns componentes principais que trabalham em conjunto.</p>"},{"location":"architecture/#componentes-principais","title":"Componentes Principais","text":"<ul> <li> <p><code>Agent</code>: O <code>Agent</code> \u00e9 o orquestrador central. Ele mant\u00e9m o hist\u00f3rico da conversa, interage com o modelo de linguagem para decidir o pr\u00f3ximo passo e despacha as chamadas para as ferramentas. Cada agente possui seu pr\u00f3prio estado, incluindo a persona e as ferramentas habilitadas.</p> </li> <li> <p><code>Runtime</code>: O <code>Runtime</code> representa o ambiente de execu\u00e7\u00e3o isolado. Ele \u00e9 respons\u00e1vel por executar comandos (<code>bash</code>), interagir com o sistema de arquivos (<code>write_file</code>, <code>read_file</code>) e gerenciar o ciclo de vida do ambiente (por exemplo, um cont\u00eainer Docker). Se o Docker n\u00e3o estiver dispon\u00edvel, o <code>runtime</code> executa os comandos localmente. Cada agente tem sua pr\u00f3pria inst\u00e2ncia de <code>runtime</code>, garantindo o isolamento entre tarefas.</p> </li> <li> <p><code>Model</code>: O <code>Model</code> \u00e9 uma interface (protocolo) que abstrai a comunica\u00e7\u00e3o com um modelo de linguagem (LLM). A implementa\u00e7\u00e3o padr\u00e3o, <code>OpenAIModel</code>, interage com APIs compat\u00edveis com a OpenAI. Voc\u00ea pode fornecer sua pr\u00f3pria implementa\u00e7\u00e3o para se conectar a diferentes back-ends de modelo.</p> </li> <li> <p><code>TaskManager</code>: O <code>TaskManager</code> gerencia a execu\u00e7\u00e3o de tarefas em segundo plano. Quando voc\u00ea usa a ferramenta <code>delegate_task</code>, o <code>TaskManager</code> cria um novo <code>Agent</code> com seu pr\u00f3prio <code>Runtime</code> para executar a tarefa de forma ass\u00edncrona, permitindo que o agente principal continue seu trabalho ou monitore o progresso da subtarefa.</p> </li> </ul>"},{"location":"architecture/#fluxo-de-uma-requisicao","title":"Fluxo de uma Requisi\u00e7\u00e3o","text":"<ol> <li>O usu\u00e1rio envia uma mensagem para o <code>Agent</code> atrav\u00e9s da CLI ou da API.</li> <li>O <code>Agent</code> adiciona a mensagem do usu\u00e1rio ao hist\u00f3rico da conversa.</li> <li>O <code>Agent</code> envia o hist\u00f3rico completo para o <code>Model</code>.</li> <li>O <code>Model</code> retorna uma resposta, que pode ser uma mensagem de texto ou uma solicita\u00e7\u00e3o para chamar uma ou mais ferramentas (<code>tool_calls</code>).</li> <li>Se for uma mensagem de texto, o <code>Agent</code> a exibe para o usu\u00e1rio.</li> <li>Se for uma chamada de ferramenta, o <code>Agent</code> invoca a fun\u00e7\u00e3o correspondente (ex: <code>tools._bash</code>), passando os argumentos necess\u00e1rios para o <code>Runtime</code>.</li> <li>O <code>Runtime</code> executa a a\u00e7\u00e3o (por exemplo, um comando <code>ls</code> no cont\u00eainer Docker).</li> <li>O resultado da execu\u00e7\u00e3o \u00e9 retornado ao <code>Agent</code>.</li> <li>O <code>Agent</code> adiciona o resultado da ferramenta ao hist\u00f3rico e, tipicamente, chama o <code>Model</code> novamente para que ele possa processar o resultado e decidir o pr\u00f3ximo passo, continuando o ciclo at\u00e9 que a tarefa seja conclu\u00edda (sinalizado pela ferramenta <code>stop</code>).</li> </ol>"},{"location":"cli/","title":"Interface de Linha de Comando (CLI)","text":"<p>A CLI do Pygent oferece uma maneira interativa de interagir com o assistente, permitindo a execu\u00e7\u00e3o de comandos, o gerenciamento de arquivos e a configura\u00e7\u00e3o do ambiente em tempo de real.</p>"},{"location":"cli/#sessao-interativa","title":"Sess\u00e3o Interativa","text":"<p>Para iniciar uma sess\u00e3o interativa, simplesmente execute <code>pygent</code> no seu terminal. Voc\u00ea pode usar v\u00e1rias op\u00e7\u00f5es para configurar a sess\u00e3o:</p> <ul> <li><code>--docker</code>/<code>--no-docker</code>: For\u00e7a a execu\u00e7\u00e3o de comandos dentro de um cont\u00eainer Docker ou localmente.</li> <li><code>--config &lt;caminho&gt;</code>: Carrega a configura\u00e7\u00e3o de um arquivo TOML espec\u00edfico.</li> <li><code>--workspace &lt;nome&gt;</code>: Define um diret\u00f3rio de trabalho para a sess\u00e3o.</li> <li><code>--load &lt;dir&gt;</code>: Carrega um snapshot de um ambiente salvo anteriormente, incluindo o workspace, hist\u00f3rico e vari\u00e1veis de ambiente.</li> <li><code>--confirm-bash</code>: Pede confirma\u00e7\u00e3o antes de executar qualquer comando com a ferramenta <code>bash</code>.</li> <li><code>--ban-cmd &lt;comando&gt;</code>: Desabilita a execu\u00e7\u00e3o de um comando espec\u00edfico.</li> </ul>"},{"location":"cli/#comandos-internos","title":"Comandos Internos","text":"<p>Dentro da sess\u00e3o interativa, voc\u00ea pode usar os seguintes comandos que come\u00e7am com <code>/</code>:</p> <ul> <li><code>/help [comando]</code>: Mostra a lista de comandos dispon\u00edveis ou a ajuda para um comando espec\u00edfico.</li> <li><code>/cmd &lt;comando&gt;</code>: Executa um comando shell diretamente no ambiente de <code>runtime</code> (local ou Docker).</li> <li><code>/cp &lt;origem&gt; [destino]</code>: Copia um arquivo do seu sistema local para o workspace do agente.</li> <li><code>/new</code>: Reinicia a conversa, limpando o hist\u00f3rico, mas mantendo o <code>runtime</code> atual (e o workspace, se for persistente).</li> <li><code>/save &lt;dir&gt;</code>: Salva o estado atual, incluindo o workspace, o hist\u00f3rico da conversa e as vari\u00e1veis de ambiente, em um diret\u00f3rio para uso posterior.</li> <li><code>/tools [list|enable|disable &lt;nome&gt;]</code>: Lista as ferramentas dispon\u00edveis ou ativa/desativa uma ferramenta espec\u00edfica durante a sess\u00e3o.</li> <li><code>/banned [list|add|remove &lt;nome&gt;]</code>: Lista, adiciona ou remove comandos da lista de comandos proibidos no <code>runtime</code>.</li> <li><code>/exit</code>: Encerra a sess\u00e3o interativa.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This page summarises the environment variables that control Pygent.  They can be exported in your shell or set via a <code>.env</code> file before running the CLI.</p> Variable Description Default <code>OPENAI_API_KEY</code> API key for OpenAI or any compatible service. \u2013 <code>OPENAI_BASE_URL</code> Base URL for the API endpoint. <code>https://api.openai.com/v1</code> <code>PYGENT_MODEL</code> Model name used for requests. <code>gpt-4.1-mini</code> <code>PYGENT_IMAGE</code> Docker image used for sandboxed execution. <code>python:3.12-slim</code> <code>PYGENT_USE_DOCKER</code> Set to <code>0</code> to run commands locally. Otherwise the runtime will try to use Docker if available. auto <code>PYGENT_MAX_TASKS</code> Maximum number of delegated tasks that can run concurrently. <code>3</code> <code>PYGENT_HISTORY_FILE</code> Path to a JSON file where the conversation history is saved. \u2013 <code>PYGENT_WORKSPACE</code> Directory used to persist the workspace between sessions. \u2013 <code>PYGENT_SNAPSHOT</code> Load environment and history from the given directory on startup. \u2013 <code>PYGENT_STEP_TIMEOUT</code> Default time limit in seconds for each step when running delegated tasks. \u2013 <code>PYGENT_TASK_TIMEOUT</code> Default overall time limit in seconds for delegated tasks. \u2013 <code>PYGENT_PERSONA_NAME</code> Name of the main agent persona. <code>Pygent</code> <code>PYGENT_PERSONA</code> Description of the main agent persona. \"a sandboxed coding assistant.\" <code>PYGENT_TASK_PERSONAS</code> List of personas for delegated agents separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_TASK_PERSONAS_JSON</code> JSON array of persona objects with name and description for delegated agents. Overrides <code>PYGENT_TASK_PERSONAS</code> if set. \u2013 <code>PYGENT_INIT_FILES</code> List of files or directories copied into the workspace at startup, separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_BANNED_COMMANDS</code> Commands that cannot be executed by the bash tool, separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_BANNED_APPS</code> Applications that cannot appear in any command, separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_LOG_FILE</code> Path to the CLI log file. <code>workspace/cli.log</code> <code>PYGENT_CONFIRM_BASH</code> Require confirmation before running bash commands (set to <code>1</code> to enable). <code>0</code> <p>Instead of setting environment variables you can create a <code>pygent.toml</code> file in the current directory or in your home folder. Values defined there are loaded at startup if the corresponding variables are unset. Example:</p> <pre><code>persona_name = \"FriendlyBot\"\npersona = \"a friendly bot\"\n\n[[task_personas]]\nname = \"tester\"\ndescription = \"runs tests\"\n\n[[task_personas]]\nname = \"developer\"\ndescription = \"implements features\"\n\ninitial_files = [\"bootstrap.py\"]\n</code></pre> <p>The keys map to the environment variables of the same name.</p> <p>You can also specify a configuration file explicitly when launching the CLI:</p> <pre><code>pygent --config path/to/pygent.toml\n</code></pre> <p>Environment variables can also be provided on the command line using the <code>-e</code> option:</p> <pre><code>pygent -e OPENAI_API_KEY=sk-... -e PYGENT_MODEL=gpt-4\n</code></pre> <p>If you need additional setup logic execute a Python file with <code>--pyconfig config.py</code>. To resume from a saved snapshot pass <code>--load DIR</code> or set <code>PYGENT_SNAPSHOT</code>.</p> <p>A practical example is included in <code>examples/sample_config.toml</code> together with the script <code>config_file_example.py</code>, which delegates a testing task:</p> <pre><code>python examples/config_file_example.py\n</code></pre> <p>See Getting Started for installation instructions and the API Reference for details about the available classes.</p>"},{"location":"custom-models/","title":"Custom Models","text":"<p>Pygent allows plugging in any model backend as long as it implements the <code>Model</code> protocol. This page collects extended examples showing how to build your own models, use the <code>openai_compat</code> helpers and return tool calls.</p>"},{"location":"custom-models/#echo-model","title":"Echo model","text":"<p>A trivial example that simply repeats the last user message. The implementation returns an <code>openai_compat.Message</code> instance.</p> <pre><code>from pygent import Agent, openai_compat\n\nclass EchoModel:\n    def chat(self, messages, model, tools):\n        last = messages[-1][\"content\"]\n        return openai_compat.Message(role=\"assistant\", content=f\"Echo: {last}\")\n\nag = Agent(model=EchoModel())\nag.step(\"test\")\n</code></pre>"},{"location":"custom-models/#calling-a-remote-api-with-openai_compat","title":"Calling a remote API with <code>openai_compat</code>","text":"<p>The <code>openai_compat</code> module ships a lightweight client mirroring the official OpenAI interface. You can use it to talk to any compatible endpoint.</p> <pre><code>from pygent import Agent, openai_compat\n\nclass HTTPModel:\n    def chat(self, messages, model, tools):\n        resp = openai_compat.chat.completions.create(\n            model=model,\n            messages=messages,\n            tools=tools,\n            tool_choice=\"auto\",\n        )\n        return resp.choices[0].message\n\nag = Agent(model=HTTPModel())\nag.step(\"who am I?\")\n</code></pre> <p>Set <code>OPENAI_BASE_URL</code> and <code>OPENAI_API_KEY</code> to target a different provider if needed.</p>"},{"location":"custom-models/#returning-tool-calls","title":"Returning tool calls","text":"<p>Custom models may trigger tools by returning a message with the <code>tool_calls</code> attribute populated. The next example runs the last user message as a <code>bash</code> command.</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\nclass BashModel:\n    def chat(self, messages, model, tools):\n        cmd = messages[-1][\"content\"]\n        call = openai_compat.ToolCall(\n            id=\"1\",\n            type=\"function\",\n            function=openai_compat.ToolCallFunction(\n                name=\"bash\",\n                arguments=json.dumps({\"cmd\": cmd}),\n            ),\n        )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[call])\n\nag = Agent(model=BashModel())\nag.step(\"echo 'hi from tool'\")\n</code></pre>"},{"location":"custom-models/#global-custom-model","title":"Global custom model","text":"<p>Use <code>set_custom_model</code> to apply a model to all new agents and delegated tasks:</p> <pre><code>from pygent import Agent\nfrom pygent.models import set_custom_model\n\nset_custom_model(EchoModel())\nag = Agent()\nag.step(\"hello\")\nset_custom_model(None)\n</code></pre>"},{"location":"custom-models/#delegating-tasks-from-a-custom-model","title":"Delegating tasks from a custom model","text":"<p>Models can call the <code>delegate_task</code> tool to start a background agent. This example delegates once and then stops.</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\nclass DelegateModel:\n    def __init__(self):\n        self.first = True\n\n    def chat(self, messages, model, tools):\n        if self.first:\n            self.first = False\n            return openai_compat.Message(\n                role=\"assistant\",\n                content=None,\n                tool_calls=[\n                    openai_compat.ToolCall(\n                        id=\"1\",\n                        type=\"function\",\n                        function=openai_compat.ToolCallFunction(\n                            name=\"delegate_task\",\n                            arguments=json.dumps({\"prompt\": \"noop\"}),\n                        ),\n                    )\n                ],\n            )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[\n            openai_compat.ToolCall(\n                id=\"2\",\n                type=\"function\",\n                function=openai_compat.ToolCallFunction(name=\"stop\", arguments=\"{}\"),\n            )\n        ])\n\nag = Agent(model=DelegateModel())\nag.run_until_stop(\"begin\", max_steps=2)\n</code></pre>"},{"location":"custom-models/#custom-tool-and-external-model-in-a-delegated-task","title":"Custom tool and external model in a delegated task","text":"<p>This scenario combines several features: defining a new tool, using an OpenAI-compatible service via <code>openai_compat</code> and delegating work to a background agent.</p> <pre><code>import json\nimport time\nfrom pygent import Agent, TaskManager, register_tool, openai_compat\n\ndef shout(rt, text: str) -&gt; str:\n    return text.upper()\n\nregister_tool(\n    \"shout\",\n    \"Uppercase some text\",\n    {\"type\": \"object\", \"properties\": {\"text\": {\"type\": \"string\"}}, \"required\": [\"text\"]},\n    shout,\n)\n\nclass HTTPModel:\n    def chat(self, messages, model, tools):\n        resp = openai_compat.chat.completions.create(\n            model=model, messages=messages, tools=tools, tool_choice=\"auto\"\n        )\n        return resp.choices[0].message\n\nclass DelegatingModel:\n    def __init__(self):\n        self.done = False\n\n    def chat(self, messages, model, tools):\n        if not self.done:\n            self.done = True\n            return openai_compat.Message(\n                role=\"assistant\",\n                content=None,\n                tool_calls=[\n                    openai_compat.ToolCall(\n                        id=\"1\",\n                        type=\"function\",\n                        function=openai_compat.ToolCallFunction(\n                            name=\"delegate_task\",\n                            arguments=json.dumps({\"prompt\": \"shout text='hi'\\nstop\"}),\n                        ),\n                    )\n                ],\n            )\n        return openai_compat.Message(role=\"assistant\", content=\"delegated\")\n\nmanager = TaskManager(agent_factory=lambda p=None: Agent(model=HTTPModel(), persona=p))\nmain = Agent(model=DelegatingModel())\n\ntask_id = manager.start_task(\"begin\", main.runtime)\nwhile manager.status(task_id) == \"running\":\n    time.sleep(1)\nprint(\"Status:\", manager.status(task_id))\n</code></pre> <p>These snippets demonstrate different ways of integrating custom logic with Pygent. See the examples directory for the full source code.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page collects small scripts demonstrating different aspects of Pygent. Each link points to the source file on GitHub.</p> <ul> <li>api_example.py \u2013 minimal use of the :class:<code>~pygent.agent.Agent</code> API.</li> <li>runtime_example.py \u2013 using the :class:<code>~pygent.runtime.Runtime</code> class directly.</li> <li>write_file_demo.py \u2013 calling the built-in tools from Python code.</li> <li>custom_model.py \u2013 implementing a simple custom model.</li> <li>custom_model_with_tool.py \u2013 custom model issuing tool calls.</li> <li>custom_tool.py \u2013 registering a custom tool.</li> <li>delegate_task_example.py \u2013 delegating work to a background agent.</li> <li>config_file_example.py \u2013 loading a config file and delegating a testing agent.</li> <li>delegate_external_tool.py \u2013 new tool using an external model service inside a delegated task.</li> </ul> <p>See the Custom Models page for a walkthrough of building your own models.</p> <p>See the Custom Models page for a walkthrough of building your own models.</p> <p>Run these with <code>python &lt;script&gt;</code> from the project root. They expect the environment variables described in the Configuration page.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Pygent is a minimalist coding assistant that runs shell commands inside a sandboxed environment. By default a Docker container is used, but if Docker is unavailable the commands run locally instead. This page shows how to install the package and gives a few examples covering the main features.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install from source in editable mode so the CLI and Python modules are available. Include the optional extras to enable Docker support and the web UI:</p> <pre><code>pip install pygent[docker,ui]\n</code></pre> <p>Python 3.9 or newer is required. If Docker is not installed omit the <code>[docker]</code> extras and commands will run on the host system.</p>"},{"location":"getting-started/#interactive-session","title":"Interactive session","text":"<p>Start an interactive session by running <code>pygent</code> in a terminal. Use the <code>--docker</code> flag to force container execution or <code>--no-docker</code> to run locally. The CLI prints the persona name and whether commands run <code>local</code> or in <code>Docker</code> when the session starts so you know which agent is active.</p> <pre><code>$ pygent --docker\nvc&gt; echo \"Hello\"\n</code></pre> <p>Each message is executed in the sandbox and the output printed. Use <code>/exit</code> to leave the session. You can also launch a simple web interface with <code>pygent ui</code> (or the old <code>pygent-ui</code> script, requires the <code>ui</code> extra).</p> <p>Use <code>/help</code> inside the CLI to list available commands or <code>/help &lt;cmd&gt;</code> for details. The helper shows <code>/cmd</code> to run a raw shell command, <code>/cp</code> to copy files into the workspace and <code>/new</code> to restart the conversation while keeping the current runtime. Use <code>/tools</code> to enable or disable specific tools on the fly. Pass <code>--confirm-bash</code> when launching the CLI to require confirmation before running any <code>bash</code> command. Add <code>--ban-cmd NAME</code> to prevent certain commands entirely. The <code>/save DIR</code> command copies the workspace, the CLI log and relevant configuration for later use.  Resume the session with <code>pygent --load DIR</code>. Use <code>/banned</code> inside the CLI to list or modify the banned commands.</p>"},{"location":"getting-started/#tool-usage","title":"Tool usage","text":"<p>During the conversation the assistant can call several built-in tools. <code>bash</code> runs shell commands and <code>write_file</code> creates files inside the workspace. For example:</p> <pre><code>vc&gt; write_file path=\"hello.txt\" content=\"Hello from Pygent\"\nvc&gt; bash cmd=\"cat hello.txt\"\n</code></pre> <p>You can disable all built-in tools with <code>pygent.clear_tools()</code> or remove a specific one with <code>pygent.remove_tool(\"bash\")</code>. Restore the defaults at any time using <code>pygent.reset_tools()</code>. The system prompt will update automatically to list the tools currently registered.</p>"},{"location":"getting-started/#using-the-api","title":"Using the API","text":"<p>The same functionality is accessible programmatically via the <code>Agent</code> class:</p> <pre><code>from pygent import Agent\n\nag = Agent()\nag.step(\"echo 'Hello World'\")\nag.runtime.cleanup()\n</code></pre> <p>See api_example.py for a complete script. Additional examples show how to implement a custom model and how to interact with the <code>Runtime</code> class directly.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Pygent communicates with the model through an OpenAI\u2011compatible API. Export your API key before running the assistant. A full list of environment variables is available in the Configuration page.</p> <p>For full control you may pass a custom model implementation to <code>Agent</code>. The file custom_model.py contains a minimal echo model example. A dedicated Custom Models page expands on this topic with additional scenarios.</p>"},{"location":"getting-started/#additional-examples","title":"Additional examples","text":"<p>Several scripts in the <code>examples/</code> directory showcase different parts of the package (see the dedicated Examples page):</p> <ul> <li>api_example.py \u2013 minimal use of the :class:<code>~pygent.agent.Agent</code> API.</li> <li>runtime_example.py \u2013 running commands through the   :class:<code>~pygent.runtime.Runtime</code> class directly.</li> <li>write_file_demo.py \u2013 calling the built-in tools from Python code.</li> <li>custom_model.py \u2013 plugging in a custom model.</li> </ul> <p>Below is the custom model snippet for reference:</p> <pre><code>from pygent import Agent, openai_compat\n\nclass EchoModel:\n    def chat(self, messages, model, tools):\n        last = messages[-1][\"content\"]\n        return openai_compat.Message(role=\"assistant\", content=f\"Echo: {last}\")\n\nag = Agent(model=EchoModel())\nag.step(\"test\")\nag.runtime.cleanup()\n</code></pre> <p>Custom models can also issue tool calls. The following model runs the last user message as a <code>bash</code> command:</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\n\nclass BashModel:\n    def chat(self, messages, model, tools):\n        cmd = messages[-1][\"content\"]\n        call = openai_compat.ToolCall(\n            id=\"1\",\n            type=\"function\",\n            function=openai_compat.ToolCallFunction(\n                name=\"bash\",\n                arguments=json.dumps({\"cmd\": cmd}),\n            ),\n        )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[call])\n\n\nag = Agent(model=BashModel())\nag.step(\"echo hi\")\nag.runtime.cleanup()\n</code></pre> <p>See the API reference for the complete list of classes and configuration options.</p>"},{"location":"tools/","title":"Ferramentas (Tools)","text":"<p>As ferramentas s\u00e3o o cora\u00e7\u00e3o da funcionalidade do Pygent, permitindo que o agente interaja com o sistema de arquivos, execute comandos e realize outras a\u00e7\u00f5es.</p>"},{"location":"tools/#ferramentas-nativas","title":"Ferramentas Nativas","text":"<p>O Pygent vem com um conjunto de ferramentas essenciais prontas para uso:</p> <ul> <li><code>bash</code>: Executa um comando shell no ambiente de execu\u00e7\u00e3o (local ou Docker).<ul> <li>Par\u00e2metros: <code>cmd</code> (string) - O comando a ser executado.</li> </ul> </li> <li><code>write_file</code>: Cria ou sobrescreve um arquivo no workspace do agente.<ul> <li>Par\u00e2metros: <code>path</code> (string), <code>content</code> (string).</li> </ul> </li> <li><code>stop</code>: Para o loop de execu\u00e7\u00e3o aut\u00f4noma do agente. \u00datil para sinalizar o fim de uma tarefa.</li> <li><code>continue</code>: Usado para solicitar uma resposta ou entrada do usu\u00e1rio, continuando a conversa.</li> </ul>"},{"location":"tools/#ferramentas-de-tarefas","title":"Ferramentas de Tarefas","text":"<p>Para gerenciar subtarefas e agentes em segundo plano, o Pygent oferece ferramentas espec\u00edficas que s\u00e3o ativadas ao registrar com <code>register_task_tools()</code>:</p> <ul> <li><code>delegate_task</code>: Cria uma nova tarefa em segundo plano com um novo agente.<ul> <li>Par\u00e2metros: <code>prompt</code> (string), <code>files</code> (lista de strings, opcional), <code>persona</code> (string, opcional), <code>timeout</code> (float, opcional).</li> </ul> </li> <li><code>task_status</code>: Verifica o status de uma tarefa delegada.<ul> <li>Par\u00e2metros: <code>task_id</code> (string).</li> </ul> </li> <li><code>collect_file</code>: Recupera um arquivo ou diret\u00f3rio de uma tarefa delegada para o workspace do agente principal.<ul> <li>Par\u00e2metros: <code>task_id</code> (string), <code>path</code> (string), <code>dest</code> (string, opcional).</li> </ul> </li> <li><code>list_personas</code>: Retorna as personas dispon\u00edveis para tarefas delegadas.</li> </ul>"},{"location":"tools/#criando-ferramentas-customizadas","title":"Criando Ferramentas Customizadas","text":"<p>Voc\u00ea pode estender facilmente o Pygent com suas pr\u00f3prias ferramentas.</p>"},{"location":"tools/#usando-register_tool","title":"Usando <code>register_tool</code>","text":"<p>A maneira mais direta de registrar uma nova ferramenta \u00e9 usando a fun\u00e7\u00e3o <code>register_tool</code>.</p> <pre><code>from pygent import Agent, register_tool\n\n# A fun\u00e7\u00e3o da ferramenta sempre recebe o runtime como primeiro argumento\ndef hello(rt, name: str) -&gt; str:\n    return f\"Hello {name}!\"\n\n# Registre a ferramenta\nregister_tool(\n    \"hello\", # Nome da ferramenta\n    \"Greet by name\", # Descri\u00e7\u00e3o\n    {\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}, \"required\": [\"name\"]}, # Schema de par\u00e2metros\n    hello # A fun\u00e7\u00e3o a ser chamada\n)\n\nag = Agent()\n# Agora o agente pode usar a ferramenta 'hello'\nag.step(\"hello name='world'\")\nag.runtime.cleanup()\n</code></pre> <p>Com certeza! Para garantir que n\u00e3o haja problemas de formata\u00e7\u00e3o, aqui est\u00e1 o conte\u00fado completo do arquivo tools.md. Voc\u00ea pode copiar todo o texto abaixo e colar em um novo arquivo chamado tools.md no seu diret\u00f3rio docs/.</p> <p>Markdown</p>"},{"location":"tools/#ferramentas-tools_1","title":"Ferramentas (Tools)","text":"<p>As ferramentas s\u00e3o o cora\u00e7\u00e3o da funcionalidade do Pygent, permitindo que o agente interaja com o sistema de arquivos, execute comandos e realize outras a\u00e7\u00f5es.</p>"},{"location":"tools/#ferramentas-nativas_1","title":"Ferramentas Nativas","text":"<p>O Pygent vem com um conjunto de ferramentas essenciais prontas para uso:</p> <ul> <li><code>bash</code>: Executa um comando shell no ambiente de execu\u00e7\u00e3o (local ou Docker).<ul> <li>Par\u00e2metros: <code>cmd</code> (string) - O comando a ser executado.</li> </ul> </li> <li><code>write_file</code>: Cria ou sobrescreve um arquivo no workspace do agente.<ul> <li>Par\u00e2metros: <code>path</code> (string), <code>content</code> (string).</li> </ul> </li> <li><code>stop</code>: Para o loop de execu\u00e7\u00e3o aut\u00f4noma do agente. \u00datil para sinalizar o fim de uma tarefa.</li> <li><code>continue</code>: Usado para solicitar uma resposta ou entrada do usu\u00e1rio, continuando a conversa.</li> </ul>"},{"location":"tools/#ferramentas-de-tarefas_1","title":"Ferramentas de Tarefas","text":"<p>Para gerenciar subtarefas e agentes em segundo plano, o Pygent oferece ferramentas espec\u00edficas que s\u00e3o ativadas ao registrar com <code>register_task_tools()</code>:</p> <ul> <li><code>delegate_task</code>: Cria uma nova tarefa em segundo plano com um novo agente.<ul> <li>Par\u00e2metros: <code>prompt</code> (string), <code>files</code> (lista de strings, opcional), <code>persona</code> (string, opcional), <code>timeout</code> (float, opcional).</li> </ul> </li> <li><code>task_status</code>: Verifica o status de uma tarefa delegada.<ul> <li>Par\u00e2metros: <code>task_id</code> (string).</li> </ul> </li> <li><code>collect_file</code>: Recupera um arquivo ou diret\u00f3rio de uma tarefa delegada para o workspace do agente principal.<ul> <li>Par\u00e2metros: <code>task_id</code> (string), <code>path</code> (string), <code>dest</code> (string, opcional).</li> </ul> </li> <li><code>list_personas</code>: Retorna as personas dispon\u00edveis para tarefas delegadas.</li> </ul>"},{"location":"tools/#criando-ferramentas-customizadas_1","title":"Criando Ferramentas Customizadas","text":"<p>Voc\u00ea pode estender facilmente o Pygent com suas pr\u00f3prias ferramentas.</p>"},{"location":"tools/#usando-register_tool_1","title":"Usando <code>register_tool</code>","text":"<p>A maneira mais direta de registrar uma nova ferramenta \u00e9 usando a fun\u00e7\u00e3o <code>register_tool</code>.</p> <pre><code>from pygent import Agent, register_tool\n\n# A fun\u00e7\u00e3o da ferramenta sempre recebe o runtime como primeiro argumento\ndef hello(rt, name: str) -&gt; str:\n    return f\"Hello {name}!\"\n\n# Registre a ferramenta\nregister_tool(\n    \"hello\", # Nome da ferramenta\n    \"Greet by name\", # Descri\u00e7\u00e3o\n    {\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}, \"required\": [\"name\"]}, # Schema de par\u00e2metros\n    hello # A fun\u00e7\u00e3o a ser chamada\n)\n\nag = Agent()\n# Agora o agente pode usar a ferramenta 'hello'\nag.step(\"hello name='world'\")\nag.runtime.cleanup()\n</code></pre>"},{"location":"tools/#usando-o-decorador-tool","title":"Usando o decorador @tool","text":"<p>Como alternativa, voc\u00ea pode usar o decorador @tool para um registro mais conciso:</p> <pre><code>from pygent import tool, Agent\n\n@tool(\n    name=\"goodbye\",\n    description=\"Say goodbye\",\n    parameters={\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}, \"required\": [\"name\"]},\n)\ndef goodbye(rt, name: str) -&gt; str:\n    return f\"Goodbye {name}!\"\n\nag = Agent()\nag.step(\"goodbye name='world'\")\nag.runtime.cleanup()\n</code></pre>"}]}