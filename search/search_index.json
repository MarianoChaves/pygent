{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pygent","text":"<p>Pygent is a minimal coding assistant that runs tasks inside an isolated Docker container whenever available. If Docker is not configured the commands run locally. This manual summarises the main commands and configuration options. See Configuration for a list of environment variables.</p> <p>The latest version of this guide is published online at marianochaves.github.io/pygent. See the Examples section for runnable scripts.</p> <p>See Getting Started for a quick tutorial or jump to the API Reference for details about the available classes.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pygent\n</code></pre> <p>Python \u2265 3.9 is required. Docker is optional; install <code>pygent[docker]</code> to enable container execution. The default model is <code>gpt-4.1-mini</code>.</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>Start an interactive session by running <code>pygent</code> in the terminal. Use the <code>--docker</code> option to run commands in a container (requires <code>pygent[docker]</code>); otherwise they execute locally. Use <code>/exit</code> to quit. Pass <code>--config path/to/pygent.toml</code> to load settings from a file. Alternatively run <code>pygent-ui</code> for a simple web interface (requires <code>pygent[ui]</code>).</p> <p>You can also use the Python API:</p> <pre><code>from pygent import Agent\nag = Agent()\nag.step(\"echo test\")\nag.runtime.cleanup()\n</code></pre> <p>Custom models are supported by implementing the <code>Model</code> protocol and passing the instance to <code>Agent</code>. They can also trigger tools by returning a message with <code>tool_calls</code> as shown in the <code>custom_model_with_tool.py</code> example. See the dedicated Custom Models page for extended examples and advanced usage.</p>"},{"location":"#development","title":"Development","text":"<p>Install optional dependencies with <code>pip install -e .[test,docs]</code> and run <code>pytest</code> to execute the tests. Use <code>mkdocs serve</code> to build this documentation locally.</p> <p>See the README file for more detailed information.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section documents the main classes and helpers exposed by Pygent. The content is generated from the package docstrings.</p>"},{"location":"api-reference/#agent","title":"Agent","text":"<p>Interactive assistant handling messages and tool execution.</p> Source code in <code>pygent/agent.py</code> <pre><code>@dataclass\nclass Agent:\n    \"\"\"Interactive assistant handling messages and tool execution.\"\"\"\n    runtime: Runtime = field(default_factory=Runtime)\n    model: Model = field(default_factory=_default_model)\n    model_name: str = DEFAULT_MODEL\n    persona: Persona = field(default_factory=lambda: DEFAULT_PERSONA)\n    system_msg: str = field(default_factory=lambda: build_system_msg(DEFAULT_PERSONA))\n    history: List[Dict[str, Any]] = field(default_factory=list)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize defaults after dataclass construction.\"\"\"\n        if not self.system_msg:\n            self.system_msg = build_system_msg(self.persona)\n        if not self.history:\n            self.history.append({\"role\": \"system\", \"content\": self.system_msg})\n\n    def step(self, user_msg: str):\n        \"\"\"Execute one round of interaction with the model.\"\"\"\n\n        self.history.append({\"role\": \"user\", \"content\": user_msg})\n\n        assistant_raw = self.model.chat(\n            self.history, self.model_name, tools.TOOL_SCHEMAS\n        )\n        assistant_msg = openai_compat.parse_message(assistant_raw)\n        self.history.append(assistant_msg)\n\n        if assistant_msg.tool_calls:\n            for call in assistant_msg.tool_calls:\n                output = tools.execute_tool(call, self.runtime)\n                self.history.append(\n                    {\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id}\n                )\n                console.print(Panel(output, title=f\"tool:{call.function.name}\"))\n        else:\n            markdown_response = Markdown(assistant_msg.content)\n            console.print(\n                Panel(\n                    markdown_response,\n                    title=\"Resposta do Agente\",\n                    title_align=\"left\",\n                    border_style=\"cyan\",\n                )\n            )\n        return assistant_msg\n\n    def run_until_stop(\n        self,\n        user_msg: str,\n        max_steps: int = 20,\n        step_timeout: Optional[float] = None,\n        max_time: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Run steps until ``stop`` is called or limits are reached.\"\"\"\n\n        if step_timeout is None:\n            env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n            step_timeout = float(env) if env else None\n        if max_time is None:\n            env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n            max_time = float(env) if env else None\n\n        msg = user_msg\n        start = time.monotonic()\n        self._timed_out = False\n        for _ in range(max_steps):\n            if max_time is not None and time.monotonic() - start &gt; max_time:\n                self.history.append(\n                    {\"role\": \"system\", \"content\": f\"[timeout after {max_time}s]\"}\n                )\n                self._timed_out = True\n                break\n            step_start = time.monotonic()\n            assistant_msg = self.step(msg)\n            if (\n                step_timeout is not None\n                and time.monotonic() - step_start &gt; step_timeout\n            ):\n                self.history.append(\n                    {\"role\": \"system\", \"content\": f\"[timeout after {step_timeout}s]\"}\n                )\n                self._timed_out = True\n                break\n            calls = assistant_msg.tool_calls or []\n            if any(c.function.name in (\"stop\", \"continue\") for c in calls):\n                break\n            msg = \"continue\"\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize defaults after dataclass construction.</p> Source code in <code>pygent/agent.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize defaults after dataclass construction.\"\"\"\n    if not self.system_msg:\n        self.system_msg = build_system_msg(self.persona)\n    if not self.history:\n        self.history.append({\"role\": \"system\", \"content\": self.system_msg})\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.run_until_stop","title":"<code>run_until_stop(user_msg, max_steps=20, step_timeout=None, max_time=None)</code>","text":"<p>Run steps until <code>stop</code> is called or limits are reached.</p> Source code in <code>pygent/agent.py</code> <pre><code>def run_until_stop(\n    self,\n    user_msg: str,\n    max_steps: int = 20,\n    step_timeout: Optional[float] = None,\n    max_time: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Run steps until ``stop`` is called or limits are reached.\"\"\"\n\n    if step_timeout is None:\n        env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n        step_timeout = float(env) if env else None\n    if max_time is None:\n        env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n        max_time = float(env) if env else None\n\n    msg = user_msg\n    start = time.monotonic()\n    self._timed_out = False\n    for _ in range(max_steps):\n        if max_time is not None and time.monotonic() - start &gt; max_time:\n            self.history.append(\n                {\"role\": \"system\", \"content\": f\"[timeout after {max_time}s]\"}\n            )\n            self._timed_out = True\n            break\n        step_start = time.monotonic()\n        assistant_msg = self.step(msg)\n        if (\n            step_timeout is not None\n            and time.monotonic() - step_start &gt; step_timeout\n        ):\n            self.history.append(\n                {\"role\": \"system\", \"content\": f\"[timeout after {step_timeout}s]\"}\n            )\n            self._timed_out = True\n            break\n        calls = assistant_msg.tool_calls or []\n        if any(c.function.name in (\"stop\", \"continue\") for c in calls):\n            break\n        msg = \"continue\"\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.step","title":"<code>step(user_msg)</code>","text":"<p>Execute one round of interaction with the model.</p> Source code in <code>pygent/agent.py</code> <pre><code>def step(self, user_msg: str):\n    \"\"\"Execute one round of interaction with the model.\"\"\"\n\n    self.history.append({\"role\": \"user\", \"content\": user_msg})\n\n    assistant_raw = self.model.chat(\n        self.history, self.model_name, tools.TOOL_SCHEMAS\n    )\n    assistant_msg = openai_compat.parse_message(assistant_raw)\n    self.history.append(assistant_msg)\n\n    if assistant_msg.tool_calls:\n        for call in assistant_msg.tool_calls:\n            output = tools.execute_tool(call, self.runtime)\n            self.history.append(\n                {\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id}\n            )\n            console.print(Panel(output, title=f\"tool:{call.function.name}\"))\n    else:\n        markdown_response = Markdown(assistant_msg.content)\n        console.print(\n            Panel(\n                markdown_response,\n                title=\"Resposta do Agente\",\n                title_align=\"left\",\n                border_style=\"cyan\",\n            )\n        )\n    return assistant_msg\n</code></pre>"},{"location":"api-reference/#runtime","title":"Runtime","text":"<p>Executes commands in a Docker container or locally if Docker is unavailable.</p> Source code in <code>pygent/runtime.py</code> <pre><code>class Runtime:\n    \"\"\"Executes commands in a Docker container or locally if Docker is unavailable.\"\"\"\n\n    def __init__(\n        self,\n        image: Optional[str] = None,\n        use_docker: Optional[bool] = None,\n        initial_files: Optional[list[str]] = None,\n    ) -&gt; None:\n        self.base_dir = Path(tempfile.mkdtemp(prefix=\"pygent_\"))\n        if initial_files is None:\n            env_files = os.getenv(\"PYGENT_INIT_FILES\")\n            if env_files:\n                initial_files = [f.strip() for f in env_files.split(os.pathsep) if f.strip()]\n        self._initial_files = initial_files or []\n        self.image = image or os.getenv(\"PYGENT_IMAGE\", \"python:3.12-slim\")\n        env_opt = os.getenv(\"PYGENT_USE_DOCKER\")\n        if use_docker is None:\n            use_docker = (env_opt != \"0\") if env_opt is not None else True\n        self._use_docker = bool(docker) and use_docker\n        if self._use_docker:\n            try:\n                self.client = docker.from_env()\n                self.container = self.client.containers.run(\n                    self.image,\n                    name=f\"pygent-{uuid.uuid4().hex[:8]}\",\n                    command=\"sleep infinity\",\n                    volumes={str(self.base_dir): {\"bind\": \"/workspace\", \"mode\": \"rw\"}},\n                    working_dir=\"/workspace\",\n                    detach=True,\n                    tty=True,\n                    network_disabled=True,\n                    mem_limit=\"512m\",\n                    pids_limit=256,\n                )\n            except Exception:\n                self._use_docker = False\n        if not self._use_docker:\n            self.client = None\n            self.container = None\n\n        # populate workspace with initial files\n        for fp in self._initial_files:\n            src = Path(fp).expanduser()\n            dest = self.base_dir / src.name\n            if src.is_dir():\n                shutil.copytree(src, dest, dirs_exist_ok=True)\n            elif src.exists():\n                dest.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(src, dest)\n\n    # ---------------- public API ----------------\n    def bash(self, cmd: str, timeout: int = 30) -&gt; str:\n        \"\"\"Run a command in the container or locally and return the output.\n\n        The executed command is always included in the returned string so the\n        caller can display what was run.\n        \"\"\"\n        if self._use_docker and self.container is not None:\n            try:\n                res = self.container.exec_run(\n                    cmd,\n                    workdir=\"/workspace\",\n                    demux=True,\n                    tty=False,\n                    stdin=False,\n                    timeout=timeout,\n                )\n                stdout, stderr = (\n                    res.output if isinstance(res.output, tuple) else (res.output, b\"\")\n                )\n                output = (stdout or b\"\").decode() + (stderr or b\"\").decode()\n                return f\"$ {cmd}\\n{output}\"\n            except Exception as exc:\n                return f\"$ {cmd}\\n[error] {exc}\"\n        try:\n            proc = subprocess.run(\n                cmd,\n                shell=True,\n                cwd=self.base_dir,\n                capture_output=True,\n                text=True,\n                stdin=subprocess.DEVNULL,\n                timeout=timeout,\n            )\n            return f\"$ {cmd}\\n{proc.stdout + proc.stderr}\"\n        except subprocess.TimeoutExpired:\n            return f\"$ {cmd}\\n[timeout after {timeout}s]\"\n        except Exception as exc:\n            return f\"$ {cmd}\\n[error] {exc}\"\n\n    def write_file(self, path: Union[str, Path], content: str) -&gt; str:\n        p = self.base_dir / path\n        p.parent.mkdir(parents=True, exist_ok=True)\n        p.write_text(content, encoding=\"utf-8\")\n        return f\"Wrote {p.relative_to(self.base_dir)}\"\n\n    def read_file(self, path: Union[str, Path], binary: bool = False) -&gt; str:\n        \"\"\"Return the contents of a file relative to the workspace.\"\"\"\n\n        p = self.base_dir / path\n        if not p.exists():\n            return f\"file {p.relative_to(self.base_dir)} not found\"\n        data = p.read_bytes()\n        if binary:\n            import base64\n\n            return base64.b64encode(data).decode()\n        try:\n            return data.decode()\n        except UnicodeDecodeError:\n            import base64\n\n            return base64.b64encode(data).decode()\n\n    def upload_file(self, src: Union[str, Path], dest: Optional[Union[str, Path]] = None) -&gt; str:\n        \"\"\"Copy a local file or directory into the workspace.\"\"\"\n\n        src_path = Path(src).expanduser()\n        if not src_path.exists():\n            return f\"file {src} not found\"\n        target = self.base_dir / (Path(dest) if dest else src_path.name)\n        if src_path.is_dir():\n            shutil.copytree(src_path, target, dirs_exist_ok=True)\n        else:\n            target.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src_path, target)\n        return f\"Uploaded {target.relative_to(self.base_dir)}\"\n\n    def export_file(self, path: Union[str, Path], dest: Union[str, Path]) -&gt; str:\n        \"\"\"Copy a file or directory from the workspace to a local path.\"\"\"\n\n        src = self.base_dir / path\n        if not src.exists():\n            return f\"file {path} not found\"\n        dest_path = Path(dest).expanduser()\n        if src.is_dir():\n            shutil.copytree(src, dest_path, dirs_exist_ok=True)\n        else:\n            dest_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest_path)\n        return f\"Exported {src.relative_to(self.base_dir)}\"\n\n    def cleanup(self) -&gt; None:\n        if self._use_docker and self.container is not None:\n            try:\n                self.container.kill()\n            finally:\n                self.container.remove(force=True)\n        shutil.rmtree(self.base_dir, ignore_errors=True)\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.bash","title":"<code>bash(cmd, timeout=30)</code>","text":"<p>Run a command in the container or locally and return the output.</p> <p>The executed command is always included in the returned string so the caller can display what was run.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def bash(self, cmd: str, timeout: int = 30) -&gt; str:\n    \"\"\"Run a command in the container or locally and return the output.\n\n    The executed command is always included in the returned string so the\n    caller can display what was run.\n    \"\"\"\n    if self._use_docker and self.container is not None:\n        try:\n            res = self.container.exec_run(\n                cmd,\n                workdir=\"/workspace\",\n                demux=True,\n                tty=False,\n                stdin=False,\n                timeout=timeout,\n            )\n            stdout, stderr = (\n                res.output if isinstance(res.output, tuple) else (res.output, b\"\")\n            )\n            output = (stdout or b\"\").decode() + (stderr or b\"\").decode()\n            return f\"$ {cmd}\\n{output}\"\n        except Exception as exc:\n            return f\"$ {cmd}\\n[error] {exc}\"\n    try:\n        proc = subprocess.run(\n            cmd,\n            shell=True,\n            cwd=self.base_dir,\n            capture_output=True,\n            text=True,\n            stdin=subprocess.DEVNULL,\n            timeout=timeout,\n        )\n        return f\"$ {cmd}\\n{proc.stdout + proc.stderr}\"\n    except subprocess.TimeoutExpired:\n        return f\"$ {cmd}\\n[timeout after {timeout}s]\"\n    except Exception as exc:\n        return f\"$ {cmd}\\n[error] {exc}\"\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.export_file","title":"<code>export_file(path, dest)</code>","text":"<p>Copy a file or directory from the workspace to a local path.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def export_file(self, path: Union[str, Path], dest: Union[str, Path]) -&gt; str:\n    \"\"\"Copy a file or directory from the workspace to a local path.\"\"\"\n\n    src = self.base_dir / path\n    if not src.exists():\n        return f\"file {path} not found\"\n    dest_path = Path(dest).expanduser()\n    if src.is_dir():\n        shutil.copytree(src, dest_path, dirs_exist_ok=True)\n    else:\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src, dest_path)\n    return f\"Exported {src.relative_to(self.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.read_file","title":"<code>read_file(path, binary=False)</code>","text":"<p>Return the contents of a file relative to the workspace.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def read_file(self, path: Union[str, Path], binary: bool = False) -&gt; str:\n    \"\"\"Return the contents of a file relative to the workspace.\"\"\"\n\n    p = self.base_dir / path\n    if not p.exists():\n        return f\"file {p.relative_to(self.base_dir)} not found\"\n    data = p.read_bytes()\n    if binary:\n        import base64\n\n        return base64.b64encode(data).decode()\n    try:\n        return data.decode()\n    except UnicodeDecodeError:\n        import base64\n\n        return base64.b64encode(data).decode()\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.upload_file","title":"<code>upload_file(src, dest=None)</code>","text":"<p>Copy a local file or directory into the workspace.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def upload_file(self, src: Union[str, Path], dest: Optional[Union[str, Path]] = None) -&gt; str:\n    \"\"\"Copy a local file or directory into the workspace.\"\"\"\n\n    src_path = Path(src).expanduser()\n    if not src_path.exists():\n        return f\"file {src} not found\"\n    target = self.base_dir / (Path(dest) if dest else src_path.name)\n    if src_path.is_dir():\n        shutil.copytree(src_path, target, dirs_exist_ok=True)\n    else:\n        target.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src_path, target)\n    return f\"Uploaded {target.relative_to(self.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#taskmanager","title":"TaskManager","text":"<p>Launch agents asynchronously and track their progress.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>class TaskManager:\n    \"\"\"Launch agents asynchronously and track their progress.\"\"\"\n\n    def __init__(\n        self,\n        agent_factory: Optional[Callable[..., \"Agent\"]] = None,\n        max_tasks: Optional[int] = None,\n        personas: Optional[list[Persona]] = None,\n    ) -&gt; None:\n        from .agent import Agent  # local import to avoid circular dependency\n\n        env_max = os.getenv(\"PYGENT_MAX_TASKS\")\n        self.max_tasks = max_tasks if max_tasks is not None else int(env_max or \"3\")\n        if agent_factory is None:\n            self.agent_factory = lambda p=None: Agent(persona=p)\n        else:\n            self.agent_factory = agent_factory\n        env_personas_json = os.getenv(\"PYGENT_TASK_PERSONAS_JSON\")\n        if personas is None and env_personas_json:\n            try:\n                data = json.loads(env_personas_json)\n                if isinstance(data, list):\n                    personas = [\n                        Persona(p.get(\"name\", \"\"), p.get(\"description\", \"\"))\n                        for p in data\n                        if isinstance(p, dict)\n                    ]\n            except Exception:\n                personas = None\n        env_personas = os.getenv(\"PYGENT_TASK_PERSONAS\")\n        if personas is None and env_personas:\n            personas = [\n                Persona(p.strip(), \"\")\n                for p in env_personas.split(os.pathsep)\n                if p.strip()\n            ]\n        if personas is None:\n            personas = [\n                Persona(\n                    os.getenv(\"PYGENT_PERSONA_NAME\", \"Pygent\"),\n                    os.getenv(\"PYGENT_PERSONA\", \"a sandboxed coding assistant.\"),\n                )\n            ]\n        self.personas = personas\n        self._persona_idx = 0\n        self.tasks: Dict[str, Task] = {}\n        self._lock = threading.Lock()\n\n    def start_task(\n        self,\n        prompt: str,\n        parent_rt: Runtime,\n        files: Optional[list[str]] = None,\n        parent_depth: int = 0,\n        step_timeout: Optional[float] = None,\n        task_timeout: Optional[float] = None,\n        persona: Union[Persona, str, None] = None,\n    ) -&gt; str:\n        \"\"\"Create a new agent and run ``prompt`` asynchronously.\n\n        ``persona`` overrides the default rotation used for delegated tasks.\n        \"\"\"\n\n        if parent_depth &gt;= 1:\n            raise RuntimeError(\"nested delegation is not allowed\")\n\n        with self._lock:\n            active = sum(t.status == \"running\" for t in self.tasks.values())\n            if active &gt;= self.max_tasks:\n                raise RuntimeError(f\"max {self.max_tasks} tasks reached\")\n\n        if step_timeout is None:\n            env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n            step_timeout = float(env) if env else 60 * 5  # default 5 minutes\n        if task_timeout is None:\n            env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n            task_timeout = float(env) if env else 60 * 20  # default 20 minutes\n\n        if persona is None:\n            persona = self.personas[self._persona_idx % len(self.personas)]\n            self._persona_idx += 1\n        elif isinstance(persona, str):\n            match = next((p for p in self.personas if p.name == persona), None)\n            persona = match or Persona(persona, \"\")\n        try:\n            agent = self.agent_factory(persona)\n        except TypeError:\n            agent = self.agent_factory()\n        setattr(agent, \"persona\", persona)\n        if not getattr(agent, \"system_msg\", None):\n            from .agent import build_system_msg  # lazy import\n\n            agent.system_msg = build_system_msg(persona)\n        setattr(agent.runtime, \"task_depth\", parent_depth + 1)\n        if files:\n            for fp in files:\n                src = parent_rt.base_dir / fp\n                dest = agent.runtime.base_dir / fp\n                if src.is_dir():\n                    shutil.copytree(src, dest, dirs_exist_ok=True)\n                elif src.exists():\n                    dest.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy(src, dest)\n        task_id = uuid.uuid4().hex[:8]\n        task = Task(id=task_id, agent=agent, thread=None)  # type: ignore[arg-type]\n\n        def run() -&gt; None:\n            try:\n                agent.run_until_stop(\n                    prompt,\n                    step_timeout=step_timeout,\n                    max_time=task_timeout,\n                )\n                if getattr(agent, \"_timed_out\", False):\n                    task.status = f\"timeout after {task_timeout}s\"\n                else:\n                    task.status = \"finished\"\n            except Exception as exc:  # pragma: no cover - error propagation\n                task.status = f\"error: {exc}\"\n\n        t = threading.Thread(target=run, daemon=True)\n        task.thread = t\n        with self._lock:\n            self.tasks[task_id] = task\n        t.start()\n        return task_id\n\n    def status(self, task_id: str) -&gt; str:\n        with self._lock:\n            task = self.tasks.get(task_id)\n        if not task:\n            return f\"Task {task_id} not found\"\n        return task.status\n\n    def collect_file(\n        self, rt: Runtime, task_id: str, path: str, dest: Optional[str] = None\n    ) -&gt; str:\n        \"\"\"Copy a file or directory from a task workspace into ``rt``.\"\"\"\n\n        with self._lock:\n            task = self.tasks.get(task_id)\n        if not task:\n            return f\"Task {task_id} not found\"\n        src = task.agent.runtime.base_dir / path\n        if not src.exists():\n            return f\"file {path} not found\"\n        dest_path = rt.base_dir / (dest or path)\n        if src.is_dir():\n            shutil.copytree(src, dest_path, dirs_exist_ok=True)\n        else:\n            dest_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest_path)\n        return f\"Retrieved {dest_path.relative_to(rt.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.task_manager.TaskManager.collect_file","title":"<code>collect_file(rt, task_id, path, dest=None)</code>","text":"<p>Copy a file or directory from a task workspace into <code>rt</code>.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>def collect_file(\n    self, rt: Runtime, task_id: str, path: str, dest: Optional[str] = None\n) -&gt; str:\n    \"\"\"Copy a file or directory from a task workspace into ``rt``.\"\"\"\n\n    with self._lock:\n        task = self.tasks.get(task_id)\n    if not task:\n        return f\"Task {task_id} not found\"\n    src = task.agent.runtime.base_dir / path\n    if not src.exists():\n        return f\"file {path} not found\"\n    dest_path = rt.base_dir / (dest or path)\n    if src.is_dir():\n        shutil.copytree(src, dest_path, dirs_exist_ok=True)\n    else:\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src, dest_path)\n    return f\"Retrieved {dest_path.relative_to(rt.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.task_manager.TaskManager.start_task","title":"<code>start_task(prompt, parent_rt, files=None, parent_depth=0, step_timeout=None, task_timeout=None, persona=None)</code>","text":"<p>Create a new agent and run <code>prompt</code> asynchronously.</p> <p><code>persona</code> overrides the default rotation used for delegated tasks.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>def start_task(\n    self,\n    prompt: str,\n    parent_rt: Runtime,\n    files: Optional[list[str]] = None,\n    parent_depth: int = 0,\n    step_timeout: Optional[float] = None,\n    task_timeout: Optional[float] = None,\n    persona: Union[Persona, str, None] = None,\n) -&gt; str:\n    \"\"\"Create a new agent and run ``prompt`` asynchronously.\n\n    ``persona`` overrides the default rotation used for delegated tasks.\n    \"\"\"\n\n    if parent_depth &gt;= 1:\n        raise RuntimeError(\"nested delegation is not allowed\")\n\n    with self._lock:\n        active = sum(t.status == \"running\" for t in self.tasks.values())\n        if active &gt;= self.max_tasks:\n            raise RuntimeError(f\"max {self.max_tasks} tasks reached\")\n\n    if step_timeout is None:\n        env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n        step_timeout = float(env) if env else 60 * 5  # default 5 minutes\n    if task_timeout is None:\n        env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n        task_timeout = float(env) if env else 60 * 20  # default 20 minutes\n\n    if persona is None:\n        persona = self.personas[self._persona_idx % len(self.personas)]\n        self._persona_idx += 1\n    elif isinstance(persona, str):\n        match = next((p for p in self.personas if p.name == persona), None)\n        persona = match or Persona(persona, \"\")\n    try:\n        agent = self.agent_factory(persona)\n    except TypeError:\n        agent = self.agent_factory()\n    setattr(agent, \"persona\", persona)\n    if not getattr(agent, \"system_msg\", None):\n        from .agent import build_system_msg  # lazy import\n\n        agent.system_msg = build_system_msg(persona)\n    setattr(agent.runtime, \"task_depth\", parent_depth + 1)\n    if files:\n        for fp in files:\n            src = parent_rt.base_dir / fp\n            dest = agent.runtime.base_dir / fp\n            if src.is_dir():\n                shutil.copytree(src, dest, dirs_exist_ok=True)\n            elif src.exists():\n                dest.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(src, dest)\n    task_id = uuid.uuid4().hex[:8]\n    task = Task(id=task_id, agent=agent, thread=None)  # type: ignore[arg-type]\n\n    def run() -&gt; None:\n        try:\n            agent.run_until_stop(\n                prompt,\n                step_timeout=step_timeout,\n                max_time=task_timeout,\n            )\n            if getattr(agent, \"_timed_out\", False):\n                task.status = f\"timeout after {task_timeout}s\"\n            else:\n                task.status = \"finished\"\n        except Exception as exc:  # pragma: no cover - error propagation\n            task.status = f\"error: {exc}\"\n\n    t = threading.Thread(target=run, daemon=True)\n    task.thread = t\n    with self._lock:\n        self.tasks[task_id] = task\n    t.start()\n    return task_id\n</code></pre>"},{"location":"api-reference/#tools","title":"Tools","text":"<p>Tool registry and helper utilities.</p>"},{"location":"api-reference/#pygent.tools.execute_tool","title":"<code>execute_tool(call, rt)</code>","text":"<p>Dispatch a tool call.</p> Source code in <code>pygent/tools.py</code> <pre><code>def execute_tool(call: Any, rt: Runtime) -&gt; str:  # pragma: no cover\n    \"\"\"Dispatch a tool call.\"\"\"\n    name = call.function.name\n    args: Dict[str, Any] = json.loads(call.function.arguments)\n    func = TOOLS.get(name)\n    if func is None:\n        return f\"\u26a0\ufe0f unknown tool {name}\"\n    return func(rt, **args)\n</code></pre>"},{"location":"api-reference/#pygent.tools.register_tool","title":"<code>register_tool(name, description, parameters, func)</code>","text":"<p>Register a new callable tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def register_tool(\n    name: str, description: str, parameters: Dict[str, Any], func: Callable[..., str]\n) -&gt; None:\n    \"\"\"Register a new callable tool.\"\"\"\n    if name in TOOLS:\n        raise ValueError(f\"tool {name} already registered\")\n    TOOLS[name] = func\n    TOOL_SCHEMAS.append(\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": name,\n                \"description\": description,\n                \"parameters\": parameters,\n            },\n        }\n    )\n</code></pre>"},{"location":"api-reference/#pygent.tools.tool","title":"<code>tool(name, description, parameters)</code>","text":"<p>Decorator for registering a tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def tool(name: str, description: str, parameters: Dict[str, Any]):\n    \"\"\"Decorator for registering a tool.\"\"\"\n\n    def decorator(func: Callable[..., str]) -&gt; Callable[..., str]:\n        register_tool(name, description, parameters, func)\n        return func\n\n    return decorator\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>This page summarises the environment variables that control Pygent.  They can be exported in your shell or set via a <code>.env</code> file before running the CLI.</p> Variable Description Default <code>OPENAI_API_KEY</code> API key for OpenAI or any compatible service. \u2013 <code>OPENAI_BASE_URL</code> Base URL for the API endpoint. <code>https://api.openai.com/v1</code> <code>PYGENT_MODEL</code> Model name used for requests. <code>gpt-4.1-mini</code> <code>PYGENT_IMAGE</code> Docker image used for sandboxed execution. <code>python:3.12-slim</code> <code>PYGENT_USE_DOCKER</code> Set to <code>0</code> to run commands locally. Otherwise the runtime will try to use Docker if available. auto <code>PYGENT_MAX_TASKS</code> Maximum number of delegated tasks that can run concurrently. <code>3</code> <code>PYGENT_STEP_TIMEOUT</code> Default time limit in seconds for each step when running delegated tasks. \u2013 <code>PYGENT_TASK_TIMEOUT</code> Default overall time limit in seconds for delegated tasks. \u2013 <code>PYGENT_PERSONA_NAME</code> Name of the main agent persona. <code>Pygent</code> <code>PYGENT_PERSONA</code> Description of the main agent persona. \"a sandboxed coding assistant.\" <code>PYGENT_TASK_PERSONAS</code> List of personas for delegated agents separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_TASK_PERSONAS_JSON</code> JSON array of persona objects with name and description for delegated agents. Overrides <code>PYGENT_TASK_PERSONAS</code> if set. \u2013 <code>PYGENT_INIT_FILES</code> List of files or directories copied into the workspace at startup, separated by <code>os.pathsep</code>. \u2013 <p>Instead of setting environment variables you can create a <code>pygent.toml</code> file in the current directory or in your home folder. Values defined there are loaded at startup if the corresponding variables are unset. Example:</p> <pre><code>persona_name = \"FriendlyBot\"\npersona = \"a friendly bot\"\n\n[[task_personas]]\nname = \"tester\"\ndescription = \"runs tests\"\n\n[[task_personas]]\nname = \"developer\"\ndescription = \"implements features\"\n\ninitial_files = [\"bootstrap.py\"]\n</code></pre> <p>The keys map to the environment variables of the same name.</p> <p>You can also specify a configuration file explicitly when launching the CLI:</p> <pre><code>pygent --config path/to/pygent.toml\n</code></pre> <p>A practical example is included in <code>examples/sample_config.toml</code> together with the script <code>config_file_example.py</code>, which delegates a testing task:</p> <pre><code>python examples/config_file_example.py\n</code></pre> <p>See Getting Started for installation instructions and the API Reference for details about the available classes.</p>"},{"location":"custom-models/","title":"Custom Models","text":"<p>Pygent allows plugging in any model backend as long as it implements the <code>Model</code> protocol. This page collects extended examples showing how to build your own models, use the <code>openai_compat</code> helpers and return tool calls.</p>"},{"location":"custom-models/#echo-model","title":"Echo model","text":"<p>A trivial example that simply repeats the last user message. The implementation returns an <code>openai_compat.Message</code> instance.</p> <pre><code>from pygent import Agent, openai_compat\n\nclass EchoModel:\n    def chat(self, messages, model, tools):\n        last = messages[-1][\"content\"]\n        return openai_compat.Message(role=\"assistant\", content=f\"Echo: {last}\")\n\nag = Agent(model=EchoModel())\nag.step(\"test\")\n</code></pre>"},{"location":"custom-models/#calling-a-remote-api-with-openai_compat","title":"Calling a remote API with <code>openai_compat</code>","text":"<p>The <code>openai_compat</code> module ships a lightweight client mirroring the official OpenAI interface. You can use it to talk to any compatible endpoint.</p> <pre><code>from pygent import Agent, openai_compat\n\nclass HTTPModel:\n    def chat(self, messages, model, tools):\n        resp = openai_compat.chat.completions.create(\n            model=model,\n            messages=messages,\n            tools=tools,\n            tool_choice=\"auto\",\n        )\n        return resp.choices[0].message\n\nag = Agent(model=HTTPModel())\nag.step(\"who am I?\")\n</code></pre> <p>Set <code>OPENAI_BASE_URL</code> and <code>OPENAI_API_KEY</code> to target a different provider if needed.</p>"},{"location":"custom-models/#returning-tool-calls","title":"Returning tool calls","text":"<p>Custom models may trigger tools by returning a message with the <code>tool_calls</code> attribute populated. The next example runs the last user message as a <code>bash</code> command.</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\nclass BashModel:\n    def chat(self, messages, model, tools):\n        cmd = messages[-1][\"content\"]\n        call = openai_compat.ToolCall(\n            id=\"1\",\n            type=\"function\",\n            function=openai_compat.ToolCallFunction(\n                name=\"bash\",\n                arguments=json.dumps({\"cmd\": cmd}),\n            ),\n        )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[call])\n\nag = Agent(model=BashModel())\nag.step(\"echo 'hi from tool'\")\n</code></pre>"},{"location":"custom-models/#global-custom-model","title":"Global custom model","text":"<p>Use <code>set_custom_model</code> to apply a model to all new agents and delegated tasks:</p> <pre><code>from pygent import Agent\nfrom pygent.models import set_custom_model\n\nset_custom_model(EchoModel())\nag = Agent()\nag.step(\"hello\")\nset_custom_model(None)\n</code></pre>"},{"location":"custom-models/#delegating-tasks-from-a-custom-model","title":"Delegating tasks from a custom model","text":"<p>Models can call the <code>delegate_task</code> tool to start a background agent. This example delegates once and then stops.</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\nclass DelegateModel:\n    def __init__(self):\n        self.first = True\n\n    def chat(self, messages, model, tools):\n        if self.first:\n            self.first = False\n            return openai_compat.Message(\n                role=\"assistant\",\n                content=None,\n                tool_calls=[\n                    openai_compat.ToolCall(\n                        id=\"1\",\n                        type=\"function\",\n                        function=openai_compat.ToolCallFunction(\n                            name=\"delegate_task\",\n                            arguments=json.dumps({\"prompt\": \"noop\"}),\n                        ),\n                    )\n                ],\n            )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[\n            openai_compat.ToolCall(\n                id=\"2\",\n                type=\"function\",\n                function=openai_compat.ToolCallFunction(name=\"stop\", arguments=\"{}\"),\n            )\n        ])\n\nag = Agent(model=DelegateModel())\nag.run_until_stop(\"begin\", max_steps=2)\n</code></pre>"},{"location":"custom-models/#custom-tool-and-external-model-in-a-delegated-task","title":"Custom tool and external model in a delegated task","text":"<p>This scenario combines several features: defining a new tool, using an OpenAI-compatible service via <code>openai_compat</code> and delegating work to a background agent.</p> <pre><code>import json\nimport time\nfrom pygent import Agent, TaskManager, register_tool, openai_compat\n\ndef shout(rt, text: str) -&gt; str:\n    return text.upper()\n\nregister_tool(\n    \"shout\",\n    \"Uppercase some text\",\n    {\"type\": \"object\", \"properties\": {\"text\": {\"type\": \"string\"}}, \"required\": [\"text\"]},\n    shout,\n)\n\nclass HTTPModel:\n    def chat(self, messages, model, tools):\n        resp = openai_compat.chat.completions.create(\n            model=model, messages=messages, tools=tools, tool_choice=\"auto\"\n        )\n        return resp.choices[0].message\n\nclass DelegatingModel:\n    def __init__(self):\n        self.done = False\n\n    def chat(self, messages, model, tools):\n        if not self.done:\n            self.done = True\n            return openai_compat.Message(\n                role=\"assistant\",\n                content=None,\n                tool_calls=[\n                    openai_compat.ToolCall(\n                        id=\"1\",\n                        type=\"function\",\n                        function=openai_compat.ToolCallFunction(\n                            name=\"delegate_task\",\n                            arguments=json.dumps({\"prompt\": \"shout text='hi'\\nstop\"}),\n                        ),\n                    )\n                ],\n            )\n        return openai_compat.Message(role=\"assistant\", content=\"delegated\")\n\nmanager = TaskManager(agent_factory=lambda p=None: Agent(model=HTTPModel(), persona=p))\nmain = Agent(model=DelegatingModel())\n\ntask_id = manager.start_task(\"begin\", main.runtime)\nwhile manager.status(task_id) == \"running\":\n    time.sleep(1)\nprint(\"Status:\", manager.status(task_id))\n</code></pre> <p>These snippets demonstrate different ways of integrating custom logic with Pygent. See the examples directory for the full source code.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page collects small scripts demonstrating different aspects of Pygent. Each link points to the source file on GitHub.</p> <ul> <li>api_example.py \u2013 minimal use of the :class:<code>~pygent.agent.Agent</code> API.</li> <li>runtime_example.py \u2013 using the :class:<code>~pygent.runtime.Runtime</code> class directly.</li> <li>write_file_demo.py \u2013 calling the built-in tools from Python code.</li> <li>custom_model.py \u2013 implementing a simple custom model.</li> <li>custom_model_with_tool.py \u2013 custom model issuing tool calls.</li> <li>custom_tool.py \u2013 registering a custom tool.</li> <li>delegate_task_example.py \u2013 delegating work to a background agent.</li> <li>config_file_example.py \u2013 loading a config file and delegating a testing agent.</li> <li>delegate_external_tool.py \u2013 new tool using an external model service inside a delegated task.</li> </ul> <p>See the Custom Models page for a walkthrough of building your own models.</p> <p>See the Custom Models page for a walkthrough of building your own models.</p> <p>Run these with <code>python &lt;script&gt;</code> from the project root. They expect the environment variables described in the Configuration page.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Pygent is a minimalist coding assistant that runs shell commands inside a sandboxed environment. By default a Docker container is used, but if Docker is unavailable the commands run locally instead. This page shows how to install the package and gives a few examples covering the main features.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install from source in editable mode so the CLI and Python modules are available. Include the optional extras to enable Docker support and the web UI:</p> <pre><code>pip install pygent[docker,ui]\n</code></pre> <p>Python 3.9 or newer is required. If Docker is not installed omit the <code>[docker]</code> extras and commands will run on the host system.</p>"},{"location":"getting-started/#interactive-session","title":"Interactive session","text":"<p>Start an interactive session by running <code>pygent</code> in a terminal. Use the <code>--docker</code> flag to force container execution or <code>--no-docker</code> to run locally.</p> <pre><code>$ pygent --docker\nvc&gt; echo \"Hello\"\n</code></pre> <p>Each message is executed in the sandbox and the output printed. Use <code>/exit</code> to leave the session. You can also launch a simple web interface with <code>pygent-ui</code> (requires the <code>ui</code> extra).</p>"},{"location":"getting-started/#tool-usage","title":"Tool usage","text":"<p>During the conversation the assistant can call several built-in tools. <code>bash</code> runs shell commands, <code>write_file</code> creates files inside the workspace and <code>upload_file</code> copies a local file or directory into the workspace. For example:</p> <pre><code>vc&gt; write_file path=\"hello.txt\" content=\"Hello from Pygent\"\nvc&gt; bash cmd=\"cat hello.txt\"\nvc&gt; upload_file src=\"/path/to/data.txt\" dest=\"data.txt\"\n</code></pre>"},{"location":"getting-started/#using-the-api","title":"Using the API","text":"<p>The same functionality is accessible programmatically via the <code>Agent</code> class:</p> <pre><code>from pygent import Agent\n\nag = Agent()\nag.step(\"echo 'Hello World'\")\nag.runtime.cleanup()\n</code></pre> <p>See api_example.py for a complete script. Additional examples show how to implement a custom model and how to interact with the <code>Runtime</code> class directly.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Pygent communicates with the model through an OpenAI\u2011compatible API. Export your API key before running the assistant. A full list of environment variables is available in the Configuration page.</p> <p>For full control you may pass a custom model implementation to <code>Agent</code>. The file custom_model.py contains a minimal echo model example. A dedicated Custom Models page expands on this topic with additional scenarios.</p>"},{"location":"getting-started/#additional-examples","title":"Additional examples","text":"<p>Several scripts in the <code>examples/</code> directory showcase different parts of the package (see the dedicated Examples page):</p> <ul> <li>api_example.py \u2013 minimal use of the :class:<code>~pygent.agent.Agent</code> API.</li> <li>runtime_example.py \u2013 running commands through the   :class:<code>~pygent.runtime.Runtime</code> class directly.</li> <li>write_file_demo.py \u2013 calling the built-in tools from Python code.</li> <li>custom_model.py \u2013 plugging in a custom model.</li> </ul> <p>Below is the custom model snippet for reference:</p> <pre><code>from pygent import Agent, openai_compat\n\nclass EchoModel:\n    def chat(self, messages, model, tools):\n        last = messages[-1][\"content\"]\n        return openai_compat.Message(role=\"assistant\", content=f\"Echo: {last}\")\n\nag = Agent(model=EchoModel())\nag.step(\"test\")\nag.runtime.cleanup()\n</code></pre> <p>Custom models can also issue tool calls. The following model runs the last user message as a <code>bash</code> command:</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\n\nclass BashModel:\n    def chat(self, messages, model, tools):\n        cmd = messages[-1][\"content\"]\n        call = openai_compat.ToolCall(\n            id=\"1\",\n            type=\"function\",\n            function=openai_compat.ToolCallFunction(\n                name=\"bash\",\n                arguments=json.dumps({\"cmd\": cmd}),\n            ),\n        )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[call])\n\n\nag = Agent(model=BashModel())\nag.step(\"echo hi\")\nag.runtime.cleanup()\n</code></pre> <p>See the API reference for the complete list of classes and configuration options.</p>"}]}