{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pygent","text":"<p>Pygent is a minimalist and powerful coding assistant designed to execute tasks in a secure and isolated environment. By default, it uses Docker containers to ensure commands are run safely, but it can also operate locally if Docker is unavailable.</p> <p>Whether you're looking to automate development tasks, generate code, or simply experiment with a secure AI assistant, Pygent offers the tools and flexibility you need.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Secure Execution: Commands run in ephemeral Docker containers by default.</li> <li>Flexibility: Integrates with language models compatible with the OpenAI API.</li> <li>Extensibility: Create your own tools, customize system prompts, and extend the CLI with custom commands.</li> <li>Persistence: Save and recover your workspace state between sessions.</li> <li>Dual Interface: Use Pygent via an interactive CLI or a simple web interface.</li> </ul>"},{"location":"#where-to-start","title":"Where to start?","text":"<ul> <li>New to Pygent? Check out our Getting Started Guide to install and run your first agent.</li> <li>Want to use the CLI? The Command Line Interface (CLI) page has all the details.</li> <li>Ready to customize? Learn how to create Tools and Custom Models.</li> <li>Want to understand how it works? The Architecture section provides an overview of the internal components.</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section documents the main classes and helpers exposed by Pygent. The content is generated from the package docstrings.</p>"},{"location":"api-reference/#agent","title":"Agent","text":"<p>Interactive assistant handling messages and tool execution.</p> Source code in <code>pygent/agent.py</code> <pre><code>@dataclass\nclass Agent:\n    \"\"\"Interactive assistant handling messages and tool execution.\"\"\"\n    runtime: Runtime = field(default_factory=Runtime)\n    model: Model = field(default_factory=_default_model)\n    model_name: str = DEFAULT_MODEL\n    persona: Persona = field(default_factory=lambda: DEFAULT_PERSONA)\n    system_msg: str = field(default_factory=lambda: build_system_msg(DEFAULT_PERSONA))\n    history: List[Dict[str, Any]] = field(default_factory=list)\n    history_file: Optional[pathlib.Path] = field(default_factory=_default_history_file)\n    disabled_tools: List[str] = field(default_factory=list)\n    log_file: Optional[pathlib.Path] = field(default_factory=_default_log_file)\n    confirm_bash: bool = field(default_factory=_default_confirm_bash)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize defaults after dataclass construction.\"\"\"\n        self._log_fp = None\n        if not self.system_msg:\n            self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n        if self.history_file and isinstance(self.history_file, (str, pathlib.Path)):\n            self.history_file = pathlib.Path(self.history_file)\n            if self.history_file.is_file():\n                try:\n                    with self.history_file.open(\"r\", encoding=\"utf-8\") as fh:\n                        data = json.load(fh)\n                except Exception:\n                    data = []\n                self.history = [\n                    openai_compat.parse_message(m) if isinstance(m, dict) else m\n                    for m in data\n                ]\n        if not self.history:\n            self.append_history({\"role\": \"system\", \"content\": self.system_msg})\n        if self.log_file is None:\n            if hasattr(self.runtime, \"base_dir\"):\n                self.log_file = pathlib.Path(getattr(self.runtime, \"base_dir\")) / \"cli.log\"\n            else:\n                self.log_file = pathlib.Path(\"cli.log\")\n        if isinstance(self.log_file, (str, pathlib.Path)):\n            self.log_file = pathlib.Path(self.log_file)\n            os.environ.setdefault(\"PYGENT_LOG_FILE\", str(self.log_file))\n            self.log_file.parent.mkdir(parents=True, exist_ok=True)\n            try:\n                self._log_fp = self.log_file.open(\"a\", encoding=\"utf-8\")\n            except Exception:\n                self._log_fp = None\n\n    def _message_dict(self, msg: Any) -&gt; Dict[str, Any]:\n        if isinstance(msg, dict):\n            return msg\n        if isinstance(msg, openai_compat.Message):\n            data = {\"role\": msg.role, \"content\": msg.content}\n            if msg.tool_calls:\n                data[\"tool_calls\"] = [asdict(tc) for tc in msg.tool_calls]\n            return data\n        raise TypeError(f\"Unsupported message type: {type(msg)!r}\")\n\n    def _save_history(self) -&gt; None:\n        if self.history_file:\n            self.history_file.parent.mkdir(parents=True, exist_ok=True)\n            with self.history_file.open(\"w\", encoding=\"utf-8\") as fh:\n                json.dump([self._message_dict(m) for m in self.history], fh)\n\n    def append_history(self, msg: Any) -&gt; None:\n        self.history.append(msg)\n        self._save_history()\n        if self._log_fp:\n            try:\n                self._log_fp.write(json.dumps(self._message_dict(msg)) + \"\\n\")\n                self._log_fp.flush()\n            except Exception:\n                pass\n\n    def refresh_system_message(self) -&gt; None:\n        \"\"\"Update the system prompt based on the current tool registry.\"\"\"\n        self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n        if self.history and self.history[0].get(\"role\") == \"system\":\n            self.history[0][\"content\"] = self.system_msg\n\n    def step(self, user_msg: str):\n        \"\"\"Execute one round of interaction with the model.\"\"\"\n\n        self.refresh_system_message()\n        self.append_history({\"role\": \"user\", \"content\": user_msg})\n\n        status_cm = (\n            console.status(\"[bold cyan]Thinking...\", spinner=\"dots\")\n            if hasattr(console, \"status\")\n            else nullcontext()\n        )\n        schemas = [\n            s\n            for s in tools.TOOL_SCHEMAS\n            if s[\"function\"][\"name\"] not in self.disabled_tools\n        ]\n        with status_cm:\n            assistant_raw = self.model.chat(\n                self.history, self.model_name, schemas\n            )\n        assistant_msg = openai_compat.parse_message(assistant_raw)\n        self.append_history(assistant_msg)\n\n        if assistant_msg.tool_calls:\n            for call in assistant_msg.tool_calls:\n                if self.confirm_bash and call.function.name == \"bash\":\n                    args = json.loads(call.function.arguments or \"{}\")\n                    cmd = args.get(\"cmd\", \"\")\n                    prompt = f\"Run command: {cmd}?\"\n                    if questionary:\n                        ok = questionary.confirm(prompt).ask()\n                    else:  # pragma: no cover - fallback for tests\n                        ok = input(f\"{prompt} [y/N]: \").lower().startswith(\"y\")\n                    if not ok:\n                        output = f\"$ {cmd}\\n[aborted]\"\n                        self.append_history({\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id})\n                        console.print(\n                            Panel(\n                                output,\n                                title=f\"{self.persona.name} tool:{call.function.name}\",\n                                box=box.ROUNDED if box else None,\n                            )\n                        )\n                        continue\n                status_cm = (\n                    console.status(\n                        f\"[green]Running {call.function.name}...\", spinner=\"line\"\n                    )\n                    if hasattr(console, \"status\")\n                    else nullcontext()\n                )\n                with status_cm:\n                    output = tools.execute_tool(call, self.runtime)\n                self.append_history(\n                    {\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id}\n                )\n                if call.function.name not in {\"continue\", \"stop\"}:\n                    console.print(\n                        Panel(\n                            output,\n                            title=f\"{self.persona.name} tool:{call.function.name}\",\n                            box=box.ROUNDED if box else None,\n                        )\n                    )\n        else:\n            markdown_response = Markdown(assistant_msg.content)\n            console.print(\n                Panel(\n                    markdown_response,\n                    title=f\"{self.persona.name} replied\",\n                    title_align=\"left\",\n                    border_style=\"cyan\",\n                    box=box.ROUNDED if box else None,\n                )\n            )\n        return assistant_msg\n\n    def run_until_stop(\n        self,\n        user_msg: str,\n        max_steps: int = 20,\n        step_timeout: Optional[float] = None,\n        max_time: Optional[float] = None,\n    ) -&gt; Optional[openai_compat.Message]:\n        \"\"\"Run steps until ``stop`` is called or limits are reached.\"\"\"\n\n        if step_timeout is None:\n            env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n            step_timeout = float(env) if env else None\n        if max_time is None:\n            env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n            max_time = float(env) if env else None\n\n        msg = user_msg\n        start = time.monotonic()\n        self._timed_out = False\n        last_msg = None\n        for _ in range(max_steps):\n            if max_time is not None and time.monotonic() - start &gt; max_time:\n                self.append_history(\n                    {\"role\": \"system\", \"content\": f\"[timeout after {max_time}s]\"}\n                )\n                self._timed_out = True\n                break\n            step_start = time.monotonic()\n            assistant_msg = self.step(msg)\n            last_msg = assistant_msg\n            if (\n                step_timeout is not None\n                and time.monotonic() - step_start &gt; step_timeout\n            ):\n                self.append_history(\n                    {\"role\": \"system\", \"content\": f\"[timeout after {step_timeout}s]\"}\n                )\n                self._timed_out = True\n                break\n            calls = assistant_msg.tool_calls or []\n            if any(c.function.name in (\"stop\", \"continue\") for c in calls):\n                break\n            msg = \"continue\"\n\n        return last_msg\n\n    def close(self) -&gt; None:\n        \"\"\"Close any open resources.\"\"\"\n        if self._log_fp:\n            try:\n                self._log_fp.close()\n            finally:\n                self._log_fp = None\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize defaults after dataclass construction.</p> Source code in <code>pygent/agent.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize defaults after dataclass construction.\"\"\"\n    self._log_fp = None\n    if not self.system_msg:\n        self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n    if self.history_file and isinstance(self.history_file, (str, pathlib.Path)):\n        self.history_file = pathlib.Path(self.history_file)\n        if self.history_file.is_file():\n            try:\n                with self.history_file.open(\"r\", encoding=\"utf-8\") as fh:\n                    data = json.load(fh)\n            except Exception:\n                data = []\n            self.history = [\n                openai_compat.parse_message(m) if isinstance(m, dict) else m\n                for m in data\n            ]\n    if not self.history:\n        self.append_history({\"role\": \"system\", \"content\": self.system_msg})\n    if self.log_file is None:\n        if hasattr(self.runtime, \"base_dir\"):\n            self.log_file = pathlib.Path(getattr(self.runtime, \"base_dir\")) / \"cli.log\"\n        else:\n            self.log_file = pathlib.Path(\"cli.log\")\n    if isinstance(self.log_file, (str, pathlib.Path)):\n        self.log_file = pathlib.Path(self.log_file)\n        os.environ.setdefault(\"PYGENT_LOG_FILE\", str(self.log_file))\n        self.log_file.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            self._log_fp = self.log_file.open(\"a\", encoding=\"utf-8\")\n        except Exception:\n            self._log_fp = None\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.close","title":"<code>close()</code>","text":"<p>Close any open resources.</p> Source code in <code>pygent/agent.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close any open resources.\"\"\"\n    if self._log_fp:\n        try:\n            self._log_fp.close()\n        finally:\n            self._log_fp = None\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.refresh_system_message","title":"<code>refresh_system_message()</code>","text":"<p>Update the system prompt based on the current tool registry.</p> Source code in <code>pygent/agent.py</code> <pre><code>def refresh_system_message(self) -&gt; None:\n    \"\"\"Update the system prompt based on the current tool registry.\"\"\"\n    self.system_msg = build_system_msg(self.persona, self.disabled_tools)\n    if self.history and self.history[0].get(\"role\") == \"system\":\n        self.history[0][\"content\"] = self.system_msg\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.run_until_stop","title":"<code>run_until_stop(user_msg, max_steps=20, step_timeout=None, max_time=None)</code>","text":"<p>Run steps until <code>stop</code> is called or limits are reached.</p> Source code in <code>pygent/agent.py</code> <pre><code>def run_until_stop(\n    self,\n    user_msg: str,\n    max_steps: int = 20,\n    step_timeout: Optional[float] = None,\n    max_time: Optional[float] = None,\n) -&gt; Optional[openai_compat.Message]:\n    \"\"\"Run steps until ``stop`` is called or limits are reached.\"\"\"\n\n    if step_timeout is None:\n        env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n        step_timeout = float(env) if env else None\n    if max_time is None:\n        env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n        max_time = float(env) if env else None\n\n    msg = user_msg\n    start = time.monotonic()\n    self._timed_out = False\n    last_msg = None\n    for _ in range(max_steps):\n        if max_time is not None and time.monotonic() - start &gt; max_time:\n            self.append_history(\n                {\"role\": \"system\", \"content\": f\"[timeout after {max_time}s]\"}\n            )\n            self._timed_out = True\n            break\n        step_start = time.monotonic()\n        assistant_msg = self.step(msg)\n        last_msg = assistant_msg\n        if (\n            step_timeout is not None\n            and time.monotonic() - step_start &gt; step_timeout\n        ):\n            self.append_history(\n                {\"role\": \"system\", \"content\": f\"[timeout after {step_timeout}s]\"}\n            )\n            self._timed_out = True\n            break\n        calls = assistant_msg.tool_calls or []\n        if any(c.function.name in (\"stop\", \"continue\") for c in calls):\n            break\n        msg = \"continue\"\n\n    return last_msg\n</code></pre>"},{"location":"api-reference/#pygent.agent.Agent.step","title":"<code>step(user_msg)</code>","text":"<p>Execute one round of interaction with the model.</p> Source code in <code>pygent/agent.py</code> <pre><code>def step(self, user_msg: str):\n    \"\"\"Execute one round of interaction with the model.\"\"\"\n\n    self.refresh_system_message()\n    self.append_history({\"role\": \"user\", \"content\": user_msg})\n\n    status_cm = (\n        console.status(\"[bold cyan]Thinking...\", spinner=\"dots\")\n        if hasattr(console, \"status\")\n        else nullcontext()\n    )\n    schemas = [\n        s\n        for s in tools.TOOL_SCHEMAS\n        if s[\"function\"][\"name\"] not in self.disabled_tools\n    ]\n    with status_cm:\n        assistant_raw = self.model.chat(\n            self.history, self.model_name, schemas\n        )\n    assistant_msg = openai_compat.parse_message(assistant_raw)\n    self.append_history(assistant_msg)\n\n    if assistant_msg.tool_calls:\n        for call in assistant_msg.tool_calls:\n            if self.confirm_bash and call.function.name == \"bash\":\n                args = json.loads(call.function.arguments or \"{}\")\n                cmd = args.get(\"cmd\", \"\")\n                prompt = f\"Run command: {cmd}?\"\n                if questionary:\n                    ok = questionary.confirm(prompt).ask()\n                else:  # pragma: no cover - fallback for tests\n                    ok = input(f\"{prompt} [y/N]: \").lower().startswith(\"y\")\n                if not ok:\n                    output = f\"$ {cmd}\\n[aborted]\"\n                    self.append_history({\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id})\n                    console.print(\n                        Panel(\n                            output,\n                            title=f\"{self.persona.name} tool:{call.function.name}\",\n                            box=box.ROUNDED if box else None,\n                        )\n                    )\n                    continue\n            status_cm = (\n                console.status(\n                    f\"[green]Running {call.function.name}...\", spinner=\"line\"\n                )\n                if hasattr(console, \"status\")\n                else nullcontext()\n            )\n            with status_cm:\n                output = tools.execute_tool(call, self.runtime)\n            self.append_history(\n                {\"role\": \"tool\", \"content\": output, \"tool_call_id\": call.id}\n            )\n            if call.function.name not in {\"continue\", \"stop\"}:\n                console.print(\n                    Panel(\n                        output,\n                        title=f\"{self.persona.name} tool:{call.function.name}\",\n                        box=box.ROUNDED if box else None,\n                    )\n                )\n    else:\n        markdown_response = Markdown(assistant_msg.content)\n        console.print(\n            Panel(\n                markdown_response,\n                title=f\"{self.persona.name} replied\",\n                title_align=\"left\",\n                border_style=\"cyan\",\n                box=box.ROUNDED if box else None,\n            )\n        )\n    return assistant_msg\n</code></pre>"},{"location":"api-reference/#runtime","title":"Runtime","text":"<p>Executes commands in a Docker container or locally if Docker is unavailable.</p> <p>If <code>workspace</code> or the environment variable <code>PYGENT_WORKSPACE</code> is set, the given directory is used as the base workspace and kept across sessions.</p> Source code in <code>pygent/runtime.py</code> <pre><code>class Runtime:\n    \"\"\"Executes commands in a Docker container or locally if Docker is unavailable.\n\n    If ``workspace`` or the environment variable ``PYGENT_WORKSPACE`` is set,\n    the given directory is used as the base workspace and kept across sessions.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Optional[str] = None,\n        use_docker: Optional[bool] = None,\n        initial_files: Optional[list[str]] = None,\n        workspace: Optional[Union[str, Path]] = None,\n        banned_commands: Optional[list[str]] = None,\n        banned_apps: Optional[list[str]] = None,\n    ) -&gt; None:\n        \"\"\"Create a new execution runtime.\n\n        ``banned_commands`` and ``banned_apps`` can be used to restrict what\n        can be run. Environment variables ``PYGENT_BANNED_COMMANDS`` and\n        ``PYGENT_BANNED_APPS`` extend these lists using ``os.pathsep`` as the\n        delimiter.\n        \"\"\"\n        env_ws = os.getenv(\"PYGENT_WORKSPACE\")\n        if workspace is None and env_ws:\n            workspace = env_ws\n        if workspace is None:\n            self.base_dir = Path.cwd() / f\"agent_{uuid.uuid4().hex[:8]}\"\n            self._persistent = False\n        else:\n            self.base_dir = Path(workspace).expanduser()\n            self._persistent = True\n        self.base_dir.mkdir(parents=True, exist_ok=True)\n        if initial_files is None:\n            env_files = os.getenv(\"PYGENT_INIT_FILES\")\n            if env_files:\n                initial_files = [f.strip() for f in env_files.split(os.pathsep) if f.strip()]\n        self._initial_files = initial_files or []\n        self.image = image or os.getenv(\"PYGENT_IMAGE\", \"python:3.12-slim\")\n        env_opt = os.getenv(\"PYGENT_USE_DOCKER\")\n        if use_docker is None:\n            use_docker = (env_opt != \"0\") if env_opt is not None else True\n        self._use_docker = bool(docker) and use_docker\n        if self._use_docker:\n            try:\n                self.client = docker.from_env()\n                self.container = self.client.containers.run(\n                    self.image,\n                    name=f\"pygent-{uuid.uuid4().hex[:8]}\",\n                    command=\"sleep infinity\",\n                    volumes={str(self.base_dir): {\"bind\": \"/workspace\", \"mode\": \"rw\"}},\n                    working_dir=\"/workspace\",\n                    detach=True,\n                    tty=True,\n                    network_disabled=True,\n                    mem_limit=\"512m\",\n                    pids_limit=256,\n                )\n            except Exception:\n                self._use_docker = False\n        if not self._use_docker:\n            self.client = None\n            self.container = None\n\n        # populate workspace with initial files\n        for fp in self._initial_files:\n            src = Path(fp).expanduser()\n            dest = self.base_dir / src.name\n            if src.is_dir():\n                shutil.copytree(src, dest, dirs_exist_ok=True)\n            elif src.exists():\n                dest.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(src, dest)\n\n        env_banned_cmds = os.getenv(\"PYGENT_BANNED_COMMANDS\")\n        env_banned_apps = os.getenv(\"PYGENT_BANNED_APPS\")\n        self.banned_commands = set(banned_commands or [])\n        if env_banned_cmds:\n            self.banned_commands.update(c.strip() for c in env_banned_cmds.split(os.pathsep) if c.strip())\n        self.banned_apps = set(banned_apps or [])\n        if env_banned_apps:\n            self.banned_apps.update(a.strip() for a in env_banned_apps.split(os.pathsep) if a.strip())\n\n    @property\n    def use_docker(self) -&gt; bool:\n        \"\"\"Return ``True`` if commands run inside a Docker container.\"\"\"\n        return self._use_docker\n\n    # ---------------- public API ----------------\n    def bash(self, cmd: str, timeout: int = 600) -&gt; str:\n        \"\"\"Run a command in the container or locally and return the output.\n\n        The executed command is always included in the returned string so the\n        caller can display what was run.\n        \"\"\"\n        tokens = cmd.split()\n        if tokens:\n            from pathlib import Path\n\n            if Path(tokens[0]).name in self.banned_commands:\n                return f\"$ {cmd}\\n[error] command '{tokens[0]}' disabled\"\n            for t in tokens:\n                if Path(t).name in self.banned_apps:\n                    return f\"$ {cmd}\\n[error] application '{Path(t).name}' disabled\"\n        if self._use_docker and self.container is not None:\n            try:\n                res = self.container.exec_run(\n                    cmd,\n                    workdir=\"/workspace\",\n                    demux=True,\n                    tty=False,\n                    stdin=False,\n                    timeout=timeout,\n                )\n                stdout, stderr = (\n                    res.output if isinstance(res.output, tuple) else (res.output, b\"\")\n                )\n                output = (stdout or b\"\").decode() + (stderr or b\"\").decode()\n                return f\"$ {cmd}\\n{output}\"\n            except Exception as exc:\n                return f\"$ {cmd}\\n[error] {exc}\"\n        try:\n            proc = subprocess.run(\n                cmd,\n                shell=True,\n                cwd=self.base_dir,\n                capture_output=True,\n                text=True,\n                stdin=subprocess.DEVNULL,\n                timeout=timeout,\n            )\n            return f\"$ {cmd}\\n{proc.stdout + proc.stderr}\"\n        except subprocess.TimeoutExpired:\n            return f\"$ {cmd}\\n[timeout after {timeout}s]\"\n        except Exception as exc:\n            return f\"$ {cmd}\\n[error] {exc}\"\n\n    def write_file(self, path: Union[str, Path], content: str) -&gt; str:\n        p = self.base_dir / path\n        p.parent.mkdir(parents=True, exist_ok=True)\n        p.write_text(content, encoding=\"utf-8\")\n        return f\"Wrote {p.relative_to(self.base_dir)}\"\n\n    def read_file(self, path: Union[str, Path], binary: bool = False) -&gt; str:\n        \"\"\"Return the contents of a file relative to the workspace.\"\"\"\n\n        p = self.base_dir / path\n        if not p.exists():\n            return f\"file {p.relative_to(self.base_dir)} not found\"\n        data = p.read_bytes()\n        if binary:\n            import base64\n\n            return base64.b64encode(data).decode()\n        try:\n            return data.decode()\n        except UnicodeDecodeError:\n            import base64\n\n            return base64.b64encode(data).decode()\n\n    def upload_file(self, src: Union[str, Path], dest: Optional[Union[str, Path]] = None) -&gt; str:\n        \"\"\"Copy a local file or directory into the workspace.\"\"\"\n\n        src_path = Path(src).expanduser()\n        if not src_path.exists():\n            return f\"file {src} not found\"\n        target = self.base_dir / (Path(dest) if dest else src_path.name)\n        if src_path.is_dir():\n            shutil.copytree(src_path, target, dirs_exist_ok=True)\n        else:\n            target.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src_path, target)\n        return f\"Uploaded {target.relative_to(self.base_dir)}\"\n\n    def export_file(self, path: Union[str, Path], dest: Union[str, Path]) -&gt; str:\n        \"\"\"Copy a file or directory from the workspace to a local path.\"\"\"\n\n        src = self.base_dir / path\n        if not src.exists():\n            return f\"file {path} not found\"\n        dest_path = Path(dest).expanduser()\n        if src.is_dir():\n            shutil.copytree(src, dest_path, dirs_exist_ok=True)\n        else:\n            dest_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest_path)\n        return f\"Exported {src.relative_to(self.base_dir)}\"\n\n    def cleanup(self) -&gt; None:\n        if self._use_docker and self.container is not None:\n            try:\n                self.container.kill()\n            finally:\n                self.container.remove(force=True)\n        if not self._persistent:\n            shutil.rmtree(self.base_dir, ignore_errors=True)\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.use_docker","title":"<code>use_docker</code>  <code>property</code>","text":"<p>Return <code>True</code> if commands run inside a Docker container.</p>"},{"location":"api-reference/#pygent.runtime.Runtime.__init__","title":"<code>__init__(image=None, use_docker=None, initial_files=None, workspace=None, banned_commands=None, banned_apps=None)</code>","text":"<p>Create a new execution runtime.</p> <p><code>banned_commands</code> and <code>banned_apps</code> can be used to restrict what can be run. Environment variables <code>PYGENT_BANNED_COMMANDS</code> and <code>PYGENT_BANNED_APPS</code> extend these lists using <code>os.pathsep</code> as the delimiter.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def __init__(\n    self,\n    image: Optional[str] = None,\n    use_docker: Optional[bool] = None,\n    initial_files: Optional[list[str]] = None,\n    workspace: Optional[Union[str, Path]] = None,\n    banned_commands: Optional[list[str]] = None,\n    banned_apps: Optional[list[str]] = None,\n) -&gt; None:\n    \"\"\"Create a new execution runtime.\n\n    ``banned_commands`` and ``banned_apps`` can be used to restrict what\n    can be run. Environment variables ``PYGENT_BANNED_COMMANDS`` and\n    ``PYGENT_BANNED_APPS`` extend these lists using ``os.pathsep`` as the\n    delimiter.\n    \"\"\"\n    env_ws = os.getenv(\"PYGENT_WORKSPACE\")\n    if workspace is None and env_ws:\n        workspace = env_ws\n    if workspace is None:\n        self.base_dir = Path.cwd() / f\"agent_{uuid.uuid4().hex[:8]}\"\n        self._persistent = False\n    else:\n        self.base_dir = Path(workspace).expanduser()\n        self._persistent = True\n    self.base_dir.mkdir(parents=True, exist_ok=True)\n    if initial_files is None:\n        env_files = os.getenv(\"PYGENT_INIT_FILES\")\n        if env_files:\n            initial_files = [f.strip() for f in env_files.split(os.pathsep) if f.strip()]\n    self._initial_files = initial_files or []\n    self.image = image or os.getenv(\"PYGENT_IMAGE\", \"python:3.12-slim\")\n    env_opt = os.getenv(\"PYGENT_USE_DOCKER\")\n    if use_docker is None:\n        use_docker = (env_opt != \"0\") if env_opt is not None else True\n    self._use_docker = bool(docker) and use_docker\n    if self._use_docker:\n        try:\n            self.client = docker.from_env()\n            self.container = self.client.containers.run(\n                self.image,\n                name=f\"pygent-{uuid.uuid4().hex[:8]}\",\n                command=\"sleep infinity\",\n                volumes={str(self.base_dir): {\"bind\": \"/workspace\", \"mode\": \"rw\"}},\n                working_dir=\"/workspace\",\n                detach=True,\n                tty=True,\n                network_disabled=True,\n                mem_limit=\"512m\",\n                pids_limit=256,\n            )\n        except Exception:\n            self._use_docker = False\n    if not self._use_docker:\n        self.client = None\n        self.container = None\n\n    # populate workspace with initial files\n    for fp in self._initial_files:\n        src = Path(fp).expanduser()\n        dest = self.base_dir / src.name\n        if src.is_dir():\n            shutil.copytree(src, dest, dirs_exist_ok=True)\n        elif src.exists():\n            dest.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest)\n\n    env_banned_cmds = os.getenv(\"PYGENT_BANNED_COMMANDS\")\n    env_banned_apps = os.getenv(\"PYGENT_BANNED_APPS\")\n    self.banned_commands = set(banned_commands or [])\n    if env_banned_cmds:\n        self.banned_commands.update(c.strip() for c in env_banned_cmds.split(os.pathsep) if c.strip())\n    self.banned_apps = set(banned_apps or [])\n    if env_banned_apps:\n        self.banned_apps.update(a.strip() for a in env_banned_apps.split(os.pathsep) if a.strip())\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.bash","title":"<code>bash(cmd, timeout=600)</code>","text":"<p>Run a command in the container or locally and return the output.</p> <p>The executed command is always included in the returned string so the caller can display what was run.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def bash(self, cmd: str, timeout: int = 600) -&gt; str:\n    \"\"\"Run a command in the container or locally and return the output.\n\n    The executed command is always included in the returned string so the\n    caller can display what was run.\n    \"\"\"\n    tokens = cmd.split()\n    if tokens:\n        from pathlib import Path\n\n        if Path(tokens[0]).name in self.banned_commands:\n            return f\"$ {cmd}\\n[error] command '{tokens[0]}' disabled\"\n        for t in tokens:\n            if Path(t).name in self.banned_apps:\n                return f\"$ {cmd}\\n[error] application '{Path(t).name}' disabled\"\n    if self._use_docker and self.container is not None:\n        try:\n            res = self.container.exec_run(\n                cmd,\n                workdir=\"/workspace\",\n                demux=True,\n                tty=False,\n                stdin=False,\n                timeout=timeout,\n            )\n            stdout, stderr = (\n                res.output if isinstance(res.output, tuple) else (res.output, b\"\")\n            )\n            output = (stdout or b\"\").decode() + (stderr or b\"\").decode()\n            return f\"$ {cmd}\\n{output}\"\n        except Exception as exc:\n            return f\"$ {cmd}\\n[error] {exc}\"\n    try:\n        proc = subprocess.run(\n            cmd,\n            shell=True,\n            cwd=self.base_dir,\n            capture_output=True,\n            text=True,\n            stdin=subprocess.DEVNULL,\n            timeout=timeout,\n        )\n        return f\"$ {cmd}\\n{proc.stdout + proc.stderr}\"\n    except subprocess.TimeoutExpired:\n        return f\"$ {cmd}\\n[timeout after {timeout}s]\"\n    except Exception as exc:\n        return f\"$ {cmd}\\n[error] {exc}\"\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.export_file","title":"<code>export_file(path, dest)</code>","text":"<p>Copy a file or directory from the workspace to a local path.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def export_file(self, path: Union[str, Path], dest: Union[str, Path]) -&gt; str:\n    \"\"\"Copy a file or directory from the workspace to a local path.\"\"\"\n\n    src = self.base_dir / path\n    if not src.exists():\n        return f\"file {path} not found\"\n    dest_path = Path(dest).expanduser()\n    if src.is_dir():\n        shutil.copytree(src, dest_path, dirs_exist_ok=True)\n    else:\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src, dest_path)\n    return f\"Exported {src.relative_to(self.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.read_file","title":"<code>read_file(path, binary=False)</code>","text":"<p>Return the contents of a file relative to the workspace.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def read_file(self, path: Union[str, Path], binary: bool = False) -&gt; str:\n    \"\"\"Return the contents of a file relative to the workspace.\"\"\"\n\n    p = self.base_dir / path\n    if not p.exists():\n        return f\"file {p.relative_to(self.base_dir)} not found\"\n    data = p.read_bytes()\n    if binary:\n        import base64\n\n        return base64.b64encode(data).decode()\n    try:\n        return data.decode()\n    except UnicodeDecodeError:\n        import base64\n\n        return base64.b64encode(data).decode()\n</code></pre>"},{"location":"api-reference/#pygent.runtime.Runtime.upload_file","title":"<code>upload_file(src, dest=None)</code>","text":"<p>Copy a local file or directory into the workspace.</p> Source code in <code>pygent/runtime.py</code> <pre><code>def upload_file(self, src: Union[str, Path], dest: Optional[Union[str, Path]] = None) -&gt; str:\n    \"\"\"Copy a local file or directory into the workspace.\"\"\"\n\n    src_path = Path(src).expanduser()\n    if not src_path.exists():\n        return f\"file {src} not found\"\n    target = self.base_dir / (Path(dest) if dest else src_path.name)\n    if src_path.is_dir():\n        shutil.copytree(src_path, target, dirs_exist_ok=True)\n    else:\n        target.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src_path, target)\n    return f\"Uploaded {target.relative_to(self.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#taskmanager","title":"TaskManager","text":"<p>Launch agents asynchronously and track their progress.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>class TaskManager:\n    \"\"\"Launch agents asynchronously and track their progress.\"\"\"\n\n    def __init__(\n        self,\n        agent_factory: Optional[Callable[..., \"Agent\"]] = None,\n        max_tasks: Optional[int] = None,\n        personas: Optional[list[Persona]] = None,\n    ) -&gt; None:\n        from .agent import Agent  # local import to avoid circular dependency\n\n        env_max = os.getenv(\"PYGENT_MAX_TASKS\")\n        self.max_tasks = max_tasks if max_tasks is not None else int(env_max or \"3\")\n        if agent_factory is None:\n            self.agent_factory = lambda p=None: Agent(persona=p)\n        else:\n            self.agent_factory = agent_factory\n        env_personas_json = os.getenv(\"PYGENT_TASK_PERSONAS_JSON\")\n        if personas is None and env_personas_json:\n            try:\n                data = json.loads(env_personas_json)\n                if isinstance(data, list):\n                    personas = [\n                        Persona(p.get(\"name\", \"\"), p.get(\"description\", \"\"))\n                        for p in data\n                        if isinstance(p, dict)\n                    ]\n            except Exception:\n                personas = None\n        env_personas = os.getenv(\"PYGENT_TASK_PERSONAS\")\n        if personas is None and env_personas:\n            personas = [\n                Persona(p.strip(), \"\")\n                for p in env_personas.split(os.pathsep)\n                if p.strip()\n            ]\n        if personas is None:\n            personas = [\n                Persona(\n                    os.getenv(\"PYGENT_PERSONA_NAME\", \"Pygent\"),\n                    os.getenv(\"PYGENT_PERSONA\", \"a sandboxed coding assistant.\"),\n                )\n            ]\n        self.personas = personas\n        self._persona_idx = 0\n        self.tasks: Dict[str, Task] = {}\n        self._lock = threading.Lock()\n\n    def start_task(\n        self,\n        prompt: str,\n        parent_rt: Runtime,\n        files: Optional[list[str]] = None,\n        parent_depth: int = 0,\n        step_timeout: Optional[float] = None,\n        task_timeout: Optional[float] = None,\n        persona: Union[Persona, str, None] = None,\n    ) -&gt; str:\n        \"\"\"Create a new agent and run ``prompt`` asynchronously.\n\n        ``persona`` overrides the default rotation used for delegated tasks.\n        \"\"\"\n\n        if parent_depth &gt;= 1:\n            raise RuntimeError(\"nested delegation is not allowed\")\n\n        with self._lock:\n            active = sum(t.status == \"running\" for t in self.tasks.values())\n            if active &gt;= self.max_tasks:\n                raise RuntimeError(f\"max {self.max_tasks} tasks reached\")\n\n        if step_timeout is None:\n            env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n            step_timeout = float(env) if env else 60 * 5  # default 5 minutes\n        if task_timeout is None:\n            env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n            task_timeout = float(env) if env else 60 * 20  # default 20 minutes\n\n        if persona is None:\n            persona = self.personas[self._persona_idx % len(self.personas)]\n            self._persona_idx += 1\n        elif isinstance(persona, str):\n            match = next((p for p in self.personas if p.name == persona), None)\n            persona = match or Persona(persona, \"\")\n        try:\n            agent = self.agent_factory(persona)\n        except TypeError:\n            agent = self.agent_factory()\n\n        from .runtime import Runtime\n        if getattr(agent, \"runtime\", None) is not None:\n            try:\n                agent.runtime.cleanup()\n            except Exception:\n                pass\n        task_dir = parent_rt.base_dir / f\"task_{uuid.uuid4().hex[:8]}\"\n        agent.runtime = Runtime(use_docker=parent_rt.use_docker, workspace=task_dir)\n        setattr(agent, \"persona\", persona)\n        if not getattr(agent, \"system_msg\", None):\n            from .agent import build_system_msg  # lazy import\n\n            agent.system_msg = build_system_msg(persona)\n        setattr(agent.runtime, \"task_depth\", parent_depth + 1)\n        if files:\n            for fp in files:\n                src = parent_rt.base_dir / fp\n                dest = agent.runtime.base_dir / fp\n                if src.is_dir():\n                    shutil.copytree(src, dest, dirs_exist_ok=True)\n                elif src.exists():\n                    dest.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy(src, dest)\n        task_id = uuid.uuid4().hex[:8]\n        task = Task(id=task_id, agent=agent, thread=None)  # type: ignore[arg-type]\n\n        def run() -&gt; None:\n            try:\n                agent.run_until_stop(\n                    prompt,\n                    step_timeout=step_timeout,\n                    max_time=task_timeout,\n                )\n                if getattr(agent, \"_timed_out\", False):\n                    task.status = f\"timeout after {task_timeout}s\"\n                else:\n                    task.status = \"finished\"\n            except Exception as exc:  # pragma: no cover - error propagation\n                task.status = f\"error: {exc}\"\n\n        t = threading.Thread(target=run, daemon=True)\n        task.thread = t\n        with self._lock:\n            self.tasks[task_id] = task\n        t.start()\n        return task_id\n\n    def status(self, task_id: str) -&gt; str:\n        with self._lock:\n            task = self.tasks.get(task_id)\n        if not task:\n            return f\"Task {task_id} not found\"\n        return task.status\n\n    def collect_file(\n        self, rt: Runtime, task_id: str, path: str, dest: Optional[str] = None\n    ) -&gt; str:\n        \"\"\"Copy a file or directory from a task workspace into ``rt``.\"\"\"\n\n        with self._lock:\n            task = self.tasks.get(task_id)\n        if not task:\n            return f\"Task {task_id} not found\"\n        src = task.agent.runtime.base_dir / path\n        if not src.exists():\n            return f\"file {path} not found\"\n        dest_path = rt.base_dir / (dest or path)\n        if src.is_dir():\n            shutil.copytree(src, dest_path, dirs_exist_ok=True)\n        else:\n            dest_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy(src, dest_path)\n        return f\"Retrieved {dest_path.relative_to(rt.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.task_manager.TaskManager.collect_file","title":"<code>collect_file(rt, task_id, path, dest=None)</code>","text":"<p>Copy a file or directory from a task workspace into <code>rt</code>.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>def collect_file(\n    self, rt: Runtime, task_id: str, path: str, dest: Optional[str] = None\n) -&gt; str:\n    \"\"\"Copy a file or directory from a task workspace into ``rt``.\"\"\"\n\n    with self._lock:\n        task = self.tasks.get(task_id)\n    if not task:\n        return f\"Task {task_id} not found\"\n    src = task.agent.runtime.base_dir / path\n    if not src.exists():\n        return f\"file {path} not found\"\n    dest_path = rt.base_dir / (dest or path)\n    if src.is_dir():\n        shutil.copytree(src, dest_path, dirs_exist_ok=True)\n    else:\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(src, dest_path)\n    return f\"Retrieved {dest_path.relative_to(rt.base_dir)}\"\n</code></pre>"},{"location":"api-reference/#pygent.task_manager.TaskManager.start_task","title":"<code>start_task(prompt, parent_rt, files=None, parent_depth=0, step_timeout=None, task_timeout=None, persona=None)</code>","text":"<p>Create a new agent and run <code>prompt</code> asynchronously.</p> <p><code>persona</code> overrides the default rotation used for delegated tasks.</p> Source code in <code>pygent/task_manager.py</code> <pre><code>def start_task(\n    self,\n    prompt: str,\n    parent_rt: Runtime,\n    files: Optional[list[str]] = None,\n    parent_depth: int = 0,\n    step_timeout: Optional[float] = None,\n    task_timeout: Optional[float] = None,\n    persona: Union[Persona, str, None] = None,\n) -&gt; str:\n    \"\"\"Create a new agent and run ``prompt`` asynchronously.\n\n    ``persona`` overrides the default rotation used for delegated tasks.\n    \"\"\"\n\n    if parent_depth &gt;= 1:\n        raise RuntimeError(\"nested delegation is not allowed\")\n\n    with self._lock:\n        active = sum(t.status == \"running\" for t in self.tasks.values())\n        if active &gt;= self.max_tasks:\n            raise RuntimeError(f\"max {self.max_tasks} tasks reached\")\n\n    if step_timeout is None:\n        env = os.getenv(\"PYGENT_STEP_TIMEOUT\")\n        step_timeout = float(env) if env else 60 * 5  # default 5 minutes\n    if task_timeout is None:\n        env = os.getenv(\"PYGENT_TASK_TIMEOUT\")\n        task_timeout = float(env) if env else 60 * 20  # default 20 minutes\n\n    if persona is None:\n        persona = self.personas[self._persona_idx % len(self.personas)]\n        self._persona_idx += 1\n    elif isinstance(persona, str):\n        match = next((p for p in self.personas if p.name == persona), None)\n        persona = match or Persona(persona, \"\")\n    try:\n        agent = self.agent_factory(persona)\n    except TypeError:\n        agent = self.agent_factory()\n\n    from .runtime import Runtime\n    if getattr(agent, \"runtime\", None) is not None:\n        try:\n            agent.runtime.cleanup()\n        except Exception:\n            pass\n    task_dir = parent_rt.base_dir / f\"task_{uuid.uuid4().hex[:8]}\"\n    agent.runtime = Runtime(use_docker=parent_rt.use_docker, workspace=task_dir)\n    setattr(agent, \"persona\", persona)\n    if not getattr(agent, \"system_msg\", None):\n        from .agent import build_system_msg  # lazy import\n\n        agent.system_msg = build_system_msg(persona)\n    setattr(agent.runtime, \"task_depth\", parent_depth + 1)\n    if files:\n        for fp in files:\n            src = parent_rt.base_dir / fp\n            dest = agent.runtime.base_dir / fp\n            if src.is_dir():\n                shutil.copytree(src, dest, dirs_exist_ok=True)\n            elif src.exists():\n                dest.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(src, dest)\n    task_id = uuid.uuid4().hex[:8]\n    task = Task(id=task_id, agent=agent, thread=None)  # type: ignore[arg-type]\n\n    def run() -&gt; None:\n        try:\n            agent.run_until_stop(\n                prompt,\n                step_timeout=step_timeout,\n                max_time=task_timeout,\n            )\n            if getattr(agent, \"_timed_out\", False):\n                task.status = f\"timeout after {task_timeout}s\"\n            else:\n                task.status = \"finished\"\n        except Exception as exc:  # pragma: no cover - error propagation\n            task.status = f\"error: {exc}\"\n\n    t = threading.Thread(target=run, daemon=True)\n    task.thread = t\n    with self._lock:\n        self.tasks[task_id] = task\n    t.start()\n    return task_id\n</code></pre>"},{"location":"api-reference/#tools","title":"Tools","text":"<p>Tool registry and helper utilities.</p>"},{"location":"api-reference/#pygent.tools.clear_tools","title":"<code>clear_tools()</code>","text":"<p>Remove all registered tools globally.</p> Source code in <code>pygent/tools.py</code> <pre><code>def clear_tools() -&gt; None:\n    \"\"\"Remove all registered tools globally.\"\"\"\n    TOOLS.clear()\n    TOOL_SCHEMAS.clear()\n</code></pre>"},{"location":"api-reference/#pygent.tools.execute_tool","title":"<code>execute_tool(call, rt)</code>","text":"<p>Dispatch a tool call.</p> Source code in <code>pygent/tools.py</code> <pre><code>def execute_tool(call: Any, rt: Runtime) -&gt; str:  # pragma: no cover\n    \"\"\"Dispatch a tool call.\"\"\"\n    name = call.function.name\n    args: Dict[str, Any] = json.loads(call.function.arguments)\n    func = TOOLS.get(name)\n    if func is None:\n        return f\"\u26a0\ufe0f unknown tool {name}\"\n    return func(rt, **args)\n</code></pre>"},{"location":"api-reference/#pygent.tools.register_tool","title":"<code>register_tool(name, description, parameters, func)</code>","text":"<p>Register a new callable tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def register_tool(\n    name: str, description: str, parameters: Dict[str, Any], func: Callable[..., str]\n) -&gt; None:\n    \"\"\"Register a new callable tool.\"\"\"\n    if name in TOOLS:\n        raise ValueError(f\"tool {name} already registered\")\n    TOOLS[name] = func\n    TOOL_SCHEMAS.append(\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": name,\n                \"description\": description,\n                \"parameters\": parameters,\n            },\n        }\n    )\n</code></pre>"},{"location":"api-reference/#pygent.tools.remove_tool","title":"<code>remove_tool(name)</code>","text":"<p>Unregister a specific tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def remove_tool(name: str) -&gt; None:\n    \"\"\"Unregister a specific tool.\"\"\"\n    if name not in TOOLS:\n        raise ValueError(f\"tool {name} not registered\")\n    del TOOLS[name]\n    for i, schema in enumerate(TOOL_SCHEMAS):\n        func = schema.get(\"function\", {})\n        if func.get(\"name\") == name:\n            TOOL_SCHEMAS.pop(i)\n            break\n</code></pre>"},{"location":"api-reference/#pygent.tools.reset_tools","title":"<code>reset_tools()</code>","text":"<p>Restore the default built-in tools.</p> Source code in <code>pygent/tools.py</code> <pre><code>def reset_tools() -&gt; None:\n    \"\"\"Restore the default built-in tools.\"\"\"\n    clear_tools()\n    TOOLS.update(BUILTIN_TOOLS)\n    TOOL_SCHEMAS.extend(deepcopy(BUILTIN_TOOL_SCHEMAS))\n</code></pre>"},{"location":"api-reference/#pygent.tools.tool","title":"<code>tool(name, description, parameters)</code>","text":"<p>Decorator for registering a tool.</p> Source code in <code>pygent/tools.py</code> <pre><code>def tool(name: str, description: str, parameters: Dict[str, Any]):\n    \"\"\"Decorator for registering a tool.\"\"\"\n\n    def decorator(func: Callable[..., str]) -&gt; Callable[..., str]:\n        register_tool(name, description, parameters, func)\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api-reference/#models","title":"Models","text":""},{"location":"api-reference/#pygent.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for chat models used by :class:<code>~pygent.agent.Agent</code>.</p> Source code in <code>pygent/models.py</code> <pre><code>class Model(Protocol):\n    \"\"\"Protocol for chat models used by :class:`~pygent.agent.Agent`.\"\"\"\n\n    def chat(self, messages: List[Dict[str, Any]], model: str, tools: Any) -&gt; Message:\n        \"\"\"Return the assistant message for the given prompt.\"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/#pygent.models.Model.chat","title":"<code>chat(messages, model, tools)</code>","text":"<p>Return the assistant message for the given prompt.</p> Source code in <code>pygent/models.py</code> <pre><code>def chat(self, messages: List[Dict[str, Any]], model: str, tools: Any) -&gt; Message:\n    \"\"\"Return the assistant message for the given prompt.\"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#pygent.models.OpenAIModel","title":"<code>OpenAIModel</code>","text":"<p>Default model using the OpenAI-compatible API.</p> Source code in <code>pygent/models.py</code> <pre><code>class OpenAIModel:\n    \"\"\"Default model using the OpenAI-compatible API.\"\"\"\n\n    def chat(self, messages: List[Dict[str, Any]], model: str, tools: Any) -&gt; Message:\n        try:\n            serialized = [\n                asdict(m) if is_dataclass(m) else m\n                for m in messages\n            ]\n            resp = openai.chat.completions.create(\n                model=model,\n                messages=serialized,\n                tools=tools,\n                tool_choice=\"auto\",\n            )\n            return resp.choices[0].message\n        except Exception as exc:\n            raise APIError(str(exc)) from exc\n</code></pre>"},{"location":"api-reference/#pygent.models.set_custom_model","title":"<code>set_custom_model(model)</code>","text":"<p>Set a global custom model used by :class:<code>~pygent.agent.Agent</code>.</p> Source code in <code>pygent/models.py</code> <pre><code>def set_custom_model(model: Optional[Model]) -&gt; None:\n    \"\"\"Set a global custom model used by :class:`~pygent.agent.Agent`.\"\"\"\n\n    global CUSTOM_MODEL\n    CUSTOM_MODEL = model\n</code></pre>"},{"location":"api-reference/#config","title":"Config","text":"<p>Utilities for loading configuration files.</p>"},{"location":"api-reference/#pygent.config.load_config","title":"<code>load_config(path=None)</code>","text":"<p>Load configuration from a TOML file and set environment variables.</p> <p>Environment variables already set take precedence over file values. Returns the configuration dictionary.</p> Source code in <code>pygent/config.py</code> <pre><code>def load_config(path: Optional[Union[str, os.PathLike[str]]] = None) -&gt; Dict[str, Any]:\n    \"\"\"Load configuration from a TOML file and set environment variables.\n\n    Environment variables already set take precedence over file values.\n    Returns the configuration dictionary.\n    \"\"\"\n    config: Dict[str, Any] = {}\n    paths = [Path(path)] if path else DEFAULT_CONFIG_FILES\n    for p in paths:\n        if p.is_file():\n            with p.open(\"rb\") as fh:\n                try:\n                    data = tomllib.load(fh)\n                except Exception:\n                    continue\n            config.update(data)\n    # update environment without overwriting existing values\n    if \"persona\" in config and \"PYGENT_PERSONA\" not in os.environ:\n        os.environ[\"PYGENT_PERSONA\"] = str(config[\"persona\"])\n    if \"persona_name\" in config and \"PYGENT_PERSONA_NAME\" not in os.environ:\n        os.environ[\"PYGENT_PERSONA_NAME\"] = str(config[\"persona_name\"])\n    if \"task_personas\" in config:\n        personas = config[\"task_personas\"]\n        if isinstance(personas, list) and personas and isinstance(personas[0], Mapping):\n            if \"PYGENT_TASK_PERSONAS_JSON\" not in os.environ:\n                os.environ[\"PYGENT_TASK_PERSONAS_JSON\"] = json.dumps(personas)\n            if \"PYGENT_TASK_PERSONAS\" not in os.environ:\n                os.environ[\"PYGENT_TASK_PERSONAS\"] = os.pathsep.join(\n                    str(p.get(\"name\", \"\")) for p in personas\n                )\n        elif \"PYGENT_TASK_PERSONAS\" not in os.environ:\n            if isinstance(personas, list):\n                os.environ[\"PYGENT_TASK_PERSONAS\"] = os.pathsep.join(\n                    str(p) for p in personas\n                )\n            else:\n                os.environ[\"PYGENT_TASK_PERSONAS\"] = str(personas)\n    if \"initial_files\" in config and \"PYGENT_INIT_FILES\" not in os.environ:\n        if isinstance(config[\"initial_files\"], list):\n            os.environ[\"PYGENT_INIT_FILES\"] = os.pathsep.join(\n                str(p) for p in config[\"initial_files\"]\n            )\n        else:\n            os.environ[\"PYGENT_INIT_FILES\"] = str(config[\"initial_files\"])\n    if \"banned_commands\" in config and \"PYGENT_BANNED_COMMANDS\" not in os.environ:\n        banned = config[\"banned_commands\"]\n        if isinstance(banned, list):\n            os.environ[\"PYGENT_BANNED_COMMANDS\"] = os.pathsep.join(str(c) for c in banned)\n        else:\n            os.environ[\"PYGENT_BANNED_COMMANDS\"] = str(banned)\n    if \"banned_apps\" in config and \"PYGENT_BANNED_APPS\" not in os.environ:\n        apps = config[\"banned_apps\"]\n        if isinstance(apps, list):\n            os.environ[\"PYGENT_BANNED_APPS\"] = os.pathsep.join(str(a) for a in apps)\n        else:\n            os.environ[\"PYGENT_BANNED_APPS\"] = str(apps)\n    return config\n</code></pre>"},{"location":"api-reference/#pygent.config.load_snapshot","title":"<code>load_snapshot(path)</code>","text":"<p>Load environment variables and history from a snapshot directory.</p> Source code in <code>pygent/config.py</code> <pre><code>def load_snapshot(path: Union[str, os.PathLike[str]]) -&gt; Path:\n    \"\"\"Load environment variables and history from a snapshot directory.\"\"\"\n\n    dest = Path(path)\n    env_file = dest / \"env.json\"\n    if env_file.is_file():\n        try:\n            data = json.loads(env_file.read_text())\n        except Exception:\n            data = {}\n        for k, v in data.items():\n            os.environ.setdefault(k, str(v))\n    ws = dest / \"workspace\"\n    os.environ[\"PYGENT_WORKSPACE\"] = str(ws)\n    hist = dest / \"history.json\"\n    if hist.is_file():\n        os.environ[\"PYGENT_HISTORY_FILE\"] = str(hist)\n    log = dest / \"cli.log\"\n    if log.is_file():\n        os.environ[\"PYGENT_LOG_FILE\"] = str(log)\n    return ws\n</code></pre>"},{"location":"api-reference/#pygent.config.run_py_config","title":"<code>run_py_config(path='config.py')</code>","text":"<p>Execute a Python configuration file if it exists.</p> Source code in <code>pygent/config.py</code> <pre><code>def run_py_config(path: Union[str, os.PathLike[str]] = \"config.py\") -&gt; None:\n    \"\"\"Execute a Python configuration file if it exists.\"\"\"\n    p = Path(path)\n    if not p.is_file():\n        return\n    spec = importlib.util.spec_from_file_location(\"pygent_config\", p)\n    if spec and spec.loader:\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n</code></pre>"},{"location":"api-reference/#errors","title":"Errors","text":""},{"location":"api-reference/#pygent.errors.APIError","title":"<code>APIError</code>","text":"<p>               Bases: <code>PygentError</code></p> <p>Raised when the OpenAI API call fails.</p> Source code in <code>pygent/errors.py</code> <pre><code>class APIError(PygentError):\n    \"\"\"Raised when the OpenAI API call fails.\"\"\"\n</code></pre>"},{"location":"api-reference/#pygent.errors.PygentError","title":"<code>PygentError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base error for the Pygent package.</p> Source code in <code>pygent/errors.py</code> <pre><code>class PygentError(Exception):\n    \"\"\"Base error for the Pygent package.\"\"\"\n</code></pre>"},{"location":"api-reference/#openai-compatibility-openai_compat","title":"OpenAI Compatibility (<code>openai_compat</code>)","text":"<p>Lightweight client compatible with the OpenAI HTTP API.</p>"},{"location":"api-reference/#pygent.openai_compat.parse_message","title":"<code>parse_message(raw)</code>","text":"<p>Return a :class:<code>Message</code> from <code>raw</code> data.</p> <p>Accepts dictionaries and objects from the official OpenAI client.</p> Source code in <code>pygent/openai_compat.py</code> <pre><code>def parse_message(raw: Any) -&gt; Message:\n    \"\"\"Return a :class:`Message` from ``raw`` data.\n\n    Accepts dictionaries and objects from the official OpenAI client.\n    \"\"\"\n    if isinstance(raw, Message):\n        return raw\n    if isinstance(raw, dict):\n        tool_calls = []\n        for tc in raw.get(\"tool_calls\", []) or []:\n            func_data = tc.get(\"function\", {})\n            func = ToolCallFunction(\n                name=func_data.get(\"name\", \"\"),\n                arguments=func_data.get(\"arguments\", \"\"),\n            )\n            tool_calls.append(\n                ToolCall(\n                    id=tc.get(\"id\", \"\"),\n                    type=tc.get(\"type\", \"\"),\n                    function=func,\n                )\n            )\n        return Message(\n            role=raw.get(\"role\", \"\"),\n            content=raw.get(\"content\"),\n            tool_calls=tool_calls or None,\n        )\n    if hasattr(raw, \"model_dump\"):\n        return parse_message(raw.model_dump())\n    if hasattr(raw, \"to_dict\"):\n        return parse_message(raw.to_dict())\n    raise TypeError(f\"Unsupported message type: {type(raw)!r}\")\n</code></pre>"},{"location":"api-reference/#commands","title":"Commands","text":""},{"location":"api-reference/#pygent.commands.Command","title":"<code>Command</code>","text":"<p>CLI command definition.</p> Source code in <code>pygent/commands.py</code> <pre><code>class Command:\n    \"\"\"CLI command definition.\"\"\"\n\n    def __init__(self, handler: Callable[[Agent, str], Optional[Agent]], description: str | None = None):\n        self.handler = handler\n        self.description = description or (handler.__doc__ or \"\")\n\n    def __call__(self, agent: Agent, arg: str) -&gt; Optional[Agent]:\n        return self.handler(agent, arg)\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_banned","title":"<code>cmd_banned(agent, arg)</code>","text":"<p>List or modify banned commands.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_banned(agent: Agent, arg: str) -&gt; None:\n    \"\"\"List or modify banned commands.\"\"\"\n    parts = arg.split()\n    if not parts or parts[0] == \"list\":\n        for name in sorted(agent.runtime.banned_commands):\n            print(name)\n        return\n    if len(parts) != 2 or parts[0] not in {\"add\", \"remove\"}:\n        print(\"usage: /banned [list|add CMD|remove CMD]\")\n        return\n    action, name = parts\n    if action == \"add\":\n        agent.runtime.banned_commands.add(name)\n        print(f\"Added {name}\")\n    else:\n        if name in agent.runtime.banned_commands:\n            agent.runtime.banned_commands.remove(name)\n            print(f\"Removed {name}\")\n        else:\n            print(f\"{name} not banned\")\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_cmd","title":"<code>cmd_cmd(agent, arg)</code>","text":"<p>Run a raw shell command in the sandbox.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_cmd(agent: Agent, arg: str) -&gt; None:\n    \"\"\"Run a raw shell command in the sandbox.\"\"\"\n    output = agent.runtime.bash(arg)\n    print(output)\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_cp","title":"<code>cmd_cp(agent, arg)</code>","text":"<p>Copy a file into the workspace: <code>/cp SRC [DEST]</code>.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_cp(agent: Agent, arg: str) -&gt; None:\n    \"\"\"Copy a file into the workspace: ``/cp SRC [DEST]``.\"\"\"\n    parts = arg.split()\n    if not parts:\n        print(\"usage: /cp SRC [DEST]\")\n        return\n    src = parts[0]\n    dest = parts[1] if len(parts) &gt; 1 else None\n    msg = agent.runtime.upload_file(src, dest)\n    print(msg)\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_help","title":"<code>cmd_help(agent, arg)</code>","text":"<p>Display available commands.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_help(agent: Agent, arg: str) -&gt; None:\n    \"\"\"Display available commands.\"\"\"\n    if arg:\n        cmd = COMMANDS.get(arg)\n        if cmd:\n            print(f\"{arg} - {cmd.description}\")\n        else:\n            print(f\"No help available for {arg}\")\n        return\n\n    print(\"Available commands:\")\n    for name, command in sorted(COMMANDS.items()):\n        print(f\"  {name:&lt;5} - {command.description}\")\n    print(\"  /exit - quit the session\")\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_new","title":"<code>cmd_new(agent, arg)</code>","text":"<p>Restart the conversation with a fresh history.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_new(agent: Agent, arg: str) -&gt; Agent:\n    \"\"\"Restart the conversation with a fresh history.\"\"\"\n    persistent = agent.runtime._persistent\n    use_docker = agent.runtime.use_docker\n    workspace = agent.runtime.base_dir if persistent else None\n    agent.runtime.cleanup()\n    return Agent(runtime=Runtime(use_docker=use_docker, workspace=workspace))\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_save","title":"<code>cmd_save(agent, arg)</code>","text":"<p>Save workspace and environment to <code>DIR</code> for later use.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_save(agent: Agent, arg: str) -&gt; None:\n    \"\"\"Save workspace and environment to ``DIR`` for later use.\"\"\"\n    if not arg:\n        print(\"usage: /save DIR\")\n        return\n    dest = Path(arg).expanduser()\n    dest.mkdir(parents=True, exist_ok=True)\n    agent.runtime.export_file(\".\", dest / \"workspace\")\n    if agent.history_file and agent.history_file.exists():\n        shutil.copy(agent.history_file, dest / \"history.json\")\n    env = {k: v for k, v in os.environ.items() if k.startswith((\"PYGENT_\", \"OPENAI_\"))}\n    (dest / \"env.json\").write_text(json.dumps(env, indent=2), encoding=\"utf-8\")\n    if agent.log_file and Path(agent.log_file).exists():\n        shutil.copy(agent.log_file, dest / \"cli.log\")\n    print(f\"Saved environment to {dest}\")\n</code></pre>"},{"location":"api-reference/#pygent.commands.cmd_tools","title":"<code>cmd_tools(agent, arg)</code>","text":"<p>Enable/disable tools at runtime or list them.</p> Source code in <code>pygent/commands.py</code> <pre><code>def cmd_tools(agent: Agent, arg: str) -&gt; None:\n    \"\"\"Enable/disable tools at runtime or list them.\"\"\"\n    parts = arg.split()\n    if not parts or parts[0] == \"list\":\n        for name in sorted(tools.TOOLS):\n            suffix = \" (disabled)\" if name in agent.disabled_tools else \"\"\n            print(f\"{name}{suffix}\")\n        return\n    if len(parts) != 2 or parts[0] not in {\"enable\", \"disable\"}:\n        print(\"usage: /tools [list|enable NAME|disable NAME]\")\n        return\n    action, name = parts\n    if action == \"enable\":\n        if name in agent.disabled_tools:\n            agent.disabled_tools.remove(name)\n            agent.refresh_system_message()\n            print(f\"Enabled {name}\")\n        else:\n            print(f\"{name} already enabled\")\n    else:\n        if name not in agent.disabled_tools:\n            agent.disabled_tools.append(name)\n            agent.refresh_system_message()\n            print(f\"Disabled {name}\")\n        else:\n            print(f\"{name} already disabled\")\n</code></pre>"},{"location":"api-reference/#pygent.commands.register_command","title":"<code>register_command(name, handler, description=None)</code>","text":"<p>Register a custom CLI command.</p> Source code in <code>pygent/commands.py</code> <pre><code>def register_command(name: str, handler: Callable[[Agent, str], Optional[Agent]], description: str | None = None) -&gt; None:\n    \"\"\"Register a custom CLI command.\"\"\"\n    if name in COMMANDS:\n        raise ValueError(f\"command {name} already registered\")\n    COMMANDS[name] = Command(handler, description)\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>Understanding Pygent's architecture helps in effectively customizing and extending the project. The system is composed of a few main components that work together.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":"<ul> <li> <p><code>Agent</code>: The <code>Agent</code> is the central orchestrator. It maintains the conversation history, interacts with the language model to decide the next step, and dispatches calls to tools. Each agent has its own state, including its persona and enabled tools.</p> </li> <li> <p><code>Runtime</code>: The <code>Runtime</code> represents the isolated execution environment. It is responsible for executing commands (<code>bash</code>), interacting with the file system (<code>write_file</code>, <code>read_file</code>), and managing the environment's lifecycle (e.g., a Docker container). If Docker is unavailable, the <code>runtime</code> executes commands locally. Each agent has its own <code>runtime</code> instance, ensuring isolation between tasks.</p> </li> <li> <p><code>Model</code>: The <code>Model</code> is an interface (protocol) that abstracts communication with a language model (LLM). The default implementation, <code>OpenAIModel</code>, interacts with OpenAI-compatible APIs. You can provide your own implementation to connect to different model backends.</p> </li> <li> <p><code>TaskManager</code>: The <code>TaskManager</code> manages the execution of background tasks. When you use the <code>delegate_task</code> tool, the <code>TaskManager</code> creates a new <code>Agent</code> with its own <code>Runtime</code> to execute the task asynchronously. This allows the main agent to continue its work or monitor the subtask's progress.</p> </li> </ul>"},{"location":"architecture/#request-flow","title":"Request Flow","text":"<ol> <li>The user sends a message to the <code>Agent</code> via the CLI or API.</li> <li>The <code>Agent</code> adds the user's message to the conversation history.</li> <li>The <code>Agent</code> sends the complete history to the <code>Model</code>.</li> <li>The <code>Model</code> returns a response, which can be a text message or a request to call one or more tools (<code>tool_calls</code>).</li> <li>If it's a text message, the <code>Agent</code> displays it to the user.</li> <li>If it's a tool call, the <code>Agent</code> invokes the corresponding function (e.g., <code>tools._bash</code>), passing the necessary arguments to the <code>Runtime</code>.</li> <li>The <code>Runtime</code> executes the action (e.g., an <code>ls</code> command in the Docker container).</li> <li>The result of the execution is returned to the <code>Agent</code>.</li> <li>The <code>Agent</code> adds the tool's result to the history and typically calls the <code>Model</code> again so it can process the result and decide the next step, continuing the cycle until the task is completed (signaled by the <code>stop</code> tool).</li> </ol>"},{"location":"cli/","title":"Command Line Interface (CLI)","text":"<p>The Pygent CLI offers an interactive way to engage with the assistant, allowing for command execution, file management, and real-time environment configuration.</p>"},{"location":"cli/#interactive-session","title":"Interactive Session","text":"<p>To start an interactive session, simply run <code>pygent</code> in your terminal. You can use various options to configure the session:</p> <ul> <li><code>--docker</code>/<code>--no-docker</code>: Forces command execution inside a Docker container or locally.</li> <li><code>--config &lt;path&gt;</code>: Loads configuration from a specific TOML file.</li> <li><code>--workspace &lt;name&gt;</code>: Defines a working directory for the session.</li> <li><code>--load &lt;dir&gt;</code>: Loads a snapshot of a previously saved environment, including the workspace, history, and environment variables.</li> <li><code>--confirm-bash</code>: Prompts for confirmation before executing any command with the <code>bash</code> tool.</li> <li><code>--ban-cmd &lt;command&gt;</code>: Disables the execution of a specific command.</li> </ul>"},{"location":"cli/#internal-commands","title":"Internal Commands","text":"<p>Within the interactive session, you can use the following commands that start with <code>/</code>:</p> <ul> <li><code>/help [command]</code>: Shows the list of available commands or help for a specific command.</li> <li><code>/cmd &lt;command&gt;</code>: Executes a shell command directly in the <code>runtime</code> environment (local or Docker).</li> <li><code>/cp &lt;source&gt; [destination]</code>: Copies a file from your local system to the agent's workspace.</li> <li><code>/new</code>: Restarts the conversation, clearing the history but keeping the current <code>runtime</code> (and workspace, if persistent).</li> <li><code>/save &lt;dir&gt;</code>: Saves the current state, including the workspace, conversation history, and environment variables, to a directory for later use.</li> <li><code>/tools [list|enable|disable &lt;name&gt;]</code>: Lists available tools or enables/disables a specific tool during the session.</li> <li><code>/banned [list|add|remove &lt;name&gt;]</code>: Lists, adds, or removes commands from the list of banned commands in the <code>runtime</code>.</li> <li><code>/exit</code>: Ends the interactive session.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This page summarises the environment variables that control Pygent.  They can be exported in your shell or set via a <code>.env</code> file before running the CLI.</p> Variable Description Default <code>OPENAI_API_KEY</code> API key for OpenAI or any compatible service. \u2013 <code>OPENAI_BASE_URL</code> Base URL for the API endpoint. <code>https://api.openai.com/v1</code> <code>PYGENT_MODEL</code> Model name used for requests. <code>gpt-4.1-mini</code> <code>PYGENT_IMAGE</code> Docker image used for sandboxed execution. <code>python:3.12-slim</code> <code>PYGENT_USE_DOCKER</code> Set to <code>0</code> to run commands locally. Otherwise the runtime will try to use Docker if available. auto <code>PYGENT_MAX_TASKS</code> Maximum number of delegated tasks that can run concurrently. <code>3</code> <code>PYGENT_HISTORY_FILE</code> Path to a JSON file where the conversation history is saved. \u2013 <code>PYGENT_WORKSPACE</code> Directory used to persist the workspace between sessions. \u2013 <code>PYGENT_SNAPSHOT</code> Load environment and history from the given directory on startup. \u2013 <code>PYGENT_STEP_TIMEOUT</code> Default time limit in seconds for each step when running delegated tasks. \u2013 <code>PYGENT_TASK_TIMEOUT</code> Default overall time limit in seconds for delegated tasks. \u2013 <code>PYGENT_PERSONA_NAME</code> Name of the main agent persona. <code>Pygent</code> <code>PYGENT_PERSONA</code> Description of the main agent persona. \"a sandboxed coding assistant.\" <code>PYGENT_TASK_PERSONAS</code> List of personas for delegated agents separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_TASK_PERSONAS_JSON</code> JSON array of persona objects with name and description for delegated agents. Overrides <code>PYGENT_TASK_PERSONAS</code> if set. \u2013 <code>PYGENT_INIT_FILES</code> List of files or directories copied into the workspace at startup, separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_BANNED_COMMANDS</code> Commands that cannot be executed by the bash tool, separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_BANNED_APPS</code> Applications that cannot appear in any command, separated by <code>os.pathsep</code>. \u2013 <code>PYGENT_LOG_FILE</code> Path to the CLI log file. <code>workspace/cli.log</code> <code>PYGENT_CONFIRM_BASH</code> Require confirmation before running bash commands (set to <code>1</code> to enable). <code>0</code> <p>Instead of setting environment variables you can create a <code>pygent.toml</code> file in the current directory or in your home folder. Values defined there are loaded at startup if the corresponding variables are unset. Example:</p> <pre><code>persona_name = \"FriendlyBot\"\npersona = \"a friendly bot\"\n\n[[task_personas]]\nname = \"tester\"\ndescription = \"runs tests\"\n\n[[task_personas]]\nname = \"developer\"\ndescription = \"implements features\"\n\ninitial_files = [\"bootstrap.py\"]\n</code></pre> <p>The keys map to the environment variables of the same name.</p> <p>You can also specify a configuration file explicitly when launching the CLI:</p> <pre><code>pygent --config path/to/pygent.toml\n</code></pre> <p>Environment variables can also be provided on the command line using the <code>-e</code> option:</p> <pre><code>pygent -e OPENAI_API_KEY=sk-... -e PYGENT_MODEL=gpt-4\n</code></pre> <p>If you need additional setup logic execute a Python file with <code>--pyconfig config.py</code>. To resume from a saved snapshot pass <code>--load DIR</code> or set <code>PYGENT_SNAPSHOT</code>.</p> <p>A practical example is included in <code>examples/sample_config.toml</code> together with the script <code>config_file_example.py</code>, which delegates a testing task:</p> <pre><code>python examples/config_file_example.py\n</code></pre> <p>See Getting Started for installation instructions and the API Reference for details about the available classes.</p>"},{"location":"custom-models/","title":"Custom Models","text":"<p>Pygent allows plugging in any model backend as long as it implements the <code>Model</code> protocol. This page collects extended examples showing how to build your own models, use the <code>openai_compat</code> helpers and return tool calls.</p>"},{"location":"custom-models/#echo-model","title":"Echo model","text":"<p>A trivial example that simply repeats the last user message. The implementation returns an <code>openai_compat.Message</code> instance.</p> <pre><code>from pygent import Agent, openai_compat\n\nclass EchoModel:\n    def chat(self, messages, model, tools):\n        last = messages[-1][\"content\"]\n        return openai_compat.Message(role=\"assistant\", content=f\"Echo: {last}\")\n\nag = Agent(model=EchoModel())\nag.step(\"test\")\n</code></pre>"},{"location":"custom-models/#calling-a-remote-api-with-openai_compat","title":"Calling a remote API with <code>openai_compat</code>","text":"<p>The <code>openai_compat</code> module ships a lightweight client mirroring the official OpenAI interface. You can use it to talk to any compatible endpoint.</p> <pre><code>from pygent import Agent, openai_compat\n\nclass HTTPModel:\n    def chat(self, messages, model, tools):\n        resp = openai_compat.chat.completions.create(\n            model=model,\n            messages=messages,\n            tools=tools,\n            tool_choice=\"auto\",\n        )\n        return resp.choices[0].message\n\nag = Agent(model=HTTPModel())\nag.step(\"who am I?\")\n</code></pre> <p>Set <code>OPENAI_BASE_URL</code> and <code>OPENAI_API_KEY</code> to target a different provider if needed.</p>"},{"location":"custom-models/#returning-tool-calls","title":"Returning tool calls","text":"<p>Custom models may trigger tools by returning a message with the <code>tool_calls</code> attribute populated. The next example runs the last user message as a <code>bash</code> command.</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\nclass BashModel:\n    def chat(self, messages, model, tools):\n        cmd = messages[-1][\"content\"]\n        call = openai_compat.ToolCall(\n            id=\"1\",\n            type=\"function\",\n            function=openai_compat.ToolCallFunction(\n                name=\"bash\",\n                arguments=json.dumps({\"cmd\": cmd}),\n            ),\n        )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[call])\n\nag = Agent(model=BashModel())\nag.step(\"echo 'hi from tool'\")\n</code></pre>"},{"location":"custom-models/#global-custom-model","title":"Global custom model","text":"<p>Use <code>set_custom_model</code> to apply a model to all new agents and delegated tasks:</p> <pre><code>from pygent import Agent\nfrom pygent.models import set_custom_model\n\nset_custom_model(EchoModel())\nag = Agent()\nag.step(\"hello\")\nset_custom_model(None)\n</code></pre>"},{"location":"custom-models/#delegating-tasks-from-a-custom-model","title":"Delegating tasks from a custom model","text":"<p>Models can call the <code>delegate_task</code> tool to start a background agent. This example delegates once and then stops.</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\nclass DelegateModel:\n    def __init__(self):\n        self.first = True\n\n    def chat(self, messages, model, tools):\n        if self.first:\n            self.first = False\n            return openai_compat.Message(\n                role=\"assistant\",\n                content=None,\n                tool_calls=[\n                    openai_compat.ToolCall(\n                        id=\"1\",\n                        type=\"function\",\n                        function=openai_compat.ToolCallFunction(\n                            name=\"delegate_task\",\n                            arguments=json.dumps({\"prompt\": \"noop\"}),\n                        ),\n                    )\n                ],\n            )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[\n            openai_compat.ToolCall(\n                id=\"2\",\n                type=\"function\",\n                function=openai_compat.ToolCallFunction(name=\"stop\", arguments=\"{}\"),\n            )\n        ])\n\nag = Agent(model=DelegateModel())\nag.run_until_stop(\"begin\", max_steps=2)\n</code></pre>"},{"location":"custom-models/#custom-tool-and-external-model-in-a-delegated-task","title":"Custom tool and external model in a delegated task","text":"<p>This scenario combines several features: defining a new tool, using an OpenAI-compatible service via <code>openai_compat</code> and delegating work to a background agent.</p> <pre><code>import json\nimport time\nfrom pygent import Agent, TaskManager, register_tool, openai_compat\n\ndef shout(rt, text: str) -&gt; str:\n    return text.upper()\n\nregister_tool(\n    \"shout\",\n    \"Uppercase some text\",\n    {\"type\": \"object\", \"properties\": {\"text\": {\"type\": \"string\"}}, \"required\": [\"text\"]},\n    shout,\n)\n\nclass HTTPModel:\n    def chat(self, messages, model, tools):\n        resp = openai_compat.chat.completions.create(\n            model=model, messages=messages, tools=tools, tool_choice=\"auto\"\n        )\n        return resp.choices[0].message\n\nclass DelegatingModel:\n    def __init__(self):\n        self.done = False\n\n    def chat(self, messages, model, tools):\n        if not self.done:\n            self.done = True\n            return openai_compat.Message(\n                role=\"assistant\",\n                content=None,\n                tool_calls=[\n                    openai_compat.ToolCall(\n                        id=\"1\",\n                        type=\"function\",\n                        function=openai_compat.ToolCallFunction(\n                            name=\"delegate_task\",\n                            arguments=json.dumps({\"prompt\": \"shout text='hi'\\nstop\"}),\n                        ),\n                    )\n                ],\n            )\n        return openai_compat.Message(role=\"assistant\", content=\"delegated\")\n\nmanager = TaskManager(agent_factory=lambda p=None: Agent(model=HTTPModel(), persona=p))\nmain = Agent(model=DelegatingModel())\n\ntask_id = manager.start_task(\"begin\", main.runtime)\nwhile manager.status(task_id) == \"running\":\n    time.sleep(1)\nprint(\"Status:\", manager.status(task_id))\n</code></pre> <p>These snippets demonstrate different ways of integrating custom logic with Pygent. See the examples directory for the full source code.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page collects small scripts demonstrating different aspects of Pygent. Each link points to the source file on GitHub.</p> <ul> <li>api_example.py \u2013 minimal use of the :class:<code>~pygent.agent.Agent</code> API.</li> <li>runtime_example.py \u2013 using the :class:<code>~pygent.runtime.Runtime</code> class directly.</li> <li>write_file_demo.py \u2013 calling the built-in tools from Python code.</li> <li>custom_model.py \u2013 implementing a simple custom model.</li> <li>custom_model_with_tool.py \u2013 custom model issuing tool calls.</li> <li>custom_tool.py \u2013 registering a custom tool.</li> <li>delegate_task_example.py \u2013 delegating work to a background agent.</li> <li>config_file_example.py \u2013 loading a config file and delegating a testing agent.</li> <li>delegate_external_tool.py \u2013 new tool using an external model service inside a delegated task.</li> </ul> <p>See the Custom Models page for a walkthrough of building your own models.</p> <p>Run these with <code>python &lt;script&gt;</code> from the project root. They expect the environment variables described in the Configuration page.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Pygent is a minimalist coding assistant that runs shell commands inside a sandboxed environment. By default a Docker container is used, but if Docker is unavailable the commands run locally instead. This page shows how to install the package and gives a few examples covering the main features.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The recommended way to install Pygent is using pip:</p> <pre><code>pip install pygent\n</code></pre> <p>To include optional features like Docker support or the web UI, you can specify extras:</p> <pre><code>pip install pygent[docker,ui]\n</code></pre> <p>Python 3.9 or newer is required. If Docker is not installed on your system, you should omit the <code>[docker]</code> extra; commands that would use Docker will then run on the host system instead. Docker itself needs to be installed separately if you wish to use containerized execution.</p> <p>For developers or those wanting the latest unreleased features, Pygent can also be installed from source:</p> <pre><code>pip install -e .\n</code></pre> <p>You can include extras like <code>[docker,ui]</code> when installing from source as well (e.g., <code>pip install -e .[docker,ui]</code>).</p>"},{"location":"getting-started/#interactive-session","title":"Interactive session","text":"<p>Start an interactive session by running <code>pygent</code> in a terminal. Use the <code>--docker</code> flag to force container execution or <code>--no-docker</code> to run locally. The CLI prints the persona name and whether commands run <code>local</code> or in <code>Docker</code> when the session starts so you know which agent is active. At the beginning of each request, the assistant proposes a short plan for how it intends to solve the task and waits for your approval before executing any commands. This helps you keep control over the session.</p> <pre><code>$ pygent --docker\nvc&gt; echo \"Hello\"\n</code></pre> <p>Each message is executed in the sandbox and the output printed. Use <code>/exit</code> to leave the session. You can also launch a simple web interface with <code>pygent ui</code> (or the old <code>pygent-ui</code> script, requires the <code>ui</code> extra).</p> <p>Use <code>/help</code> inside the CLI to list available commands or <code>/help &lt;cmd&gt;</code> for details. The helper shows <code>/cmd</code> to run a raw shell command, <code>/cp</code> to copy files into the workspace and <code>/new</code> to restart the conversation while keeping the current runtime. Use <code>/tools</code> to enable or disable specific tools on the fly. Pass <code>--confirm-bash</code> when launching the CLI to require confirmation before running any <code>bash</code> command. Add <code>--ban-cmd NAME</code> to prevent certain commands entirely. The <code>/save DIR</code> command copies the workspace, the CLI log and relevant configuration for later use.  Resume the session with <code>pygent --load DIR</code>. Use <code>/banned</code> inside the CLI to list or modify the banned commands.</p>"},{"location":"getting-started/#tool-usage","title":"Tool usage","text":"<p>During the conversation the assistant can call several built-in tools. <code>bash</code> runs shell commands and <code>write_file</code> creates files inside the workspace. For example:</p> <pre><code>vc&gt; write_file path=\"hello.txt\" content=\"Hello from Pygent\"\nvc&gt; bash cmd=\"cat hello.txt\"\n</code></pre> <p>You can disable all built-in tools with <code>pygent.clear_tools()</code> or remove a specific one with <code>pygent.remove_tool(\"bash\")</code>. Restore the defaults at any time using <code>pygent.reset_tools()</code>. The system prompt will update automatically to list the tools currently registered.</p>"},{"location":"getting-started/#using-the-api","title":"Using the API","text":"<p>The same functionality is accessible programmatically via the <code>Agent</code> class:</p> <pre><code>from pygent import Agent\n\nag = Agent()\nag.step(\"echo 'Hello World'\")\nag.runtime.cleanup()\n</code></pre> <p>See api_example.py for a complete script. Additional examples show how to implement a custom model and how to interact with the <code>Runtime</code> class directly.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Pygent communicates with the model through an OpenAI\u2011compatible API. Export your API key before running the assistant. A full list of environment variables is available in the Configuration page.</p> <p>For full control you may pass a custom model implementation to <code>Agent</code>. The file custom_model.py contains a minimal echo model example. A dedicated Custom Models page expands on this topic with additional scenarios.</p>"},{"location":"getting-started/#additional-examples","title":"Additional examples","text":"<p>Several scripts in the <code>examples/</code> directory showcase different parts of the package (see the dedicated Examples page):</p> <ul> <li>api_example.py \u2013 minimal use of the :class:<code>~pygent.agent.Agent</code> API.</li> <li>runtime_example.py \u2013 running commands through the   :class:<code>~pygent.runtime.Runtime</code> class directly.</li> <li>write_file_demo.py \u2013 calling the built-in tools from Python code.</li> <li>custom_model.py \u2013 plugging in a custom model.</li> </ul> <p>Below is the custom model snippet for reference:</p> <pre><code>from pygent import Agent, openai_compat\n\nclass EchoModel:\n    def chat(self, messages, model, tools):\n        last = messages[-1][\"content\"]\n        return openai_compat.Message(role=\"assistant\", content=f\"Echo: {last}\")\n\nag = Agent(model=EchoModel())\nag.step(\"test\")\nag.runtime.cleanup()\n</code></pre> <p>Custom models can also issue tool calls. The following model runs the last user message as a <code>bash</code> command:</p> <pre><code>import json\nfrom pygent import Agent, openai_compat\n\n\nclass BashModel:\n    def chat(self, messages, model, tools):\n        cmd = messages[-1][\"content\"]\n        call = openai_compat.ToolCall(\n            id=\"1\",\n            type=\"function\",\n            function=openai_compat.ToolCallFunction(\n                name=\"bash\",\n                arguments=json.dumps({\"cmd\": cmd}),\n            ),\n        )\n        return openai_compat.Message(role=\"assistant\", content=None, tool_calls=[call])\n\n\nag = Agent(model=BashModel())\nag.step(\"echo hi\")\nag.runtime.cleanup()\n</code></pre> <p>See the API reference for the complete list of classes and configuration options.</p>"},{"location":"tools/","title":"Tools","text":"<p>Tools are at the heart of Pygent's functionality, allowing the agent to interact with the file system, execute commands, and perform other actions.</p>"},{"location":"tools/#native-tools","title":"Native Tools","text":"<p>Pygent comes with a set of essential tools ready to use:</p> <ul> <li><code>bash</code>: Executes a shell command in the execution environment (local or Docker).<ul> <li>Parameters: <code>cmd</code> (string) - The command to be executed.</li> </ul> </li> <li><code>write_file</code>: Creates or overwrites a file in the agent's workspace.<ul> <li>Parameters: <code>path</code> (string), <code>content</code> (string).</li> </ul> </li> <li><code>stop</code>: Stops the agent's autonomous execution loop. Useful for signaling the end of a task.</li> <li><code>continue</code>: Used to request a response or input from the user, continuing the conversation.</li> </ul>"},{"location":"tools/#task-tools","title":"Task Tools","text":"<p>To manage subtasks and background agents, Pygent offers specific tools that are activated by registering with <code>register_task_tools()</code>:</p> <ul> <li><code>delegate_task</code>: Creates a new background task with a new agent.<ul> <li>Parameters: <code>prompt</code> (string), <code>files</code> (list of strings, optional), <code>persona</code> (string, optional), <code>timeout</code> (float, optional).</li> </ul> </li> <li><code>task_status</code>: Checks the status of a delegated task.<ul> <li>Parameters: <code>task_id</code> (string).</li> </ul> </li> <li><code>collect_file</code>: Retrieves a file or directory from a delegated task to the main agent's workspace.<ul> <li>Parameters: <code>task_id</code> (string), <code>path</code> (string), <code>dest</code> (string, optional).</li> </ul> </li> <li><code>list_personas</code>: Returns the available personas for delegated tasks.</li> </ul>"},{"location":"tools/#creating-custom-tools","title":"Creating Custom Tools","text":"<p>You can easily extend Pygent with your own tools.</p>"},{"location":"tools/#using-register_tool","title":"Using <code>register_tool</code>","text":"<p>The most direct way to register a new tool is using the <code>register_tool</code> function.</p> <pre><code>from pygent import Agent, register_tool\n\n# The tool function always receives the runtime as the first argument\ndef hello(rt, name: str) -&gt; str:\n    return f\"Hello {name}!\"\n\n# Register the tool\nregister_tool(\n    \"hello\", # Tool name\n    \"Greet by name\", # Description\n    {\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}, \"required\": [\"name\"]}, # Parameter schema\n    hello # The function to be called\n)\n\nag = Agent()\n# Now the agent can use the 'hello' tool\nag.step(\"hello name='world'\")\nag.runtime.cleanup()\n</code></pre>"},{"location":"tools/#using-the-tool-decorator","title":"Using the <code>@tool</code> decorator","text":"<p>Alternatively, you can use the <code>@tool</code> decorator for a more concise registration:</p> <pre><code>from pygent import tool, Agent\n\n@tool(\n    name=\"goodbye\",\n    description=\"Say goodbye\",\n    parameters={\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}, \"required\": [\"name\"]},\n)\ndef goodbye(rt, name: str) -&gt; str:\n    return f\"Goodbye {name}!\"\n\nag = Agent()\nag.step(\"goodbye name='world'\")\nag.runtime.cleanup()\n</code></pre>"}]}